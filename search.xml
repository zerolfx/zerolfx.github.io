<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【题解】HackerRank - Sherlock's Array Merging Algorithm]]></title>
    <url>%2F2017%2F07%2F03%2FSherlock-s-Array-Merging-Algorithm%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/sherlocks-array-merging-algorithm/problem 题解 每一列的数在原数列中是连续且单调增的 每一列数的个数是单调减的 如果原数列是单调递增的，可以使用如下代码。其中 dp[i][j] 表示前 i 个数分成若干组且最后一组的大小为 j 的总方案数。 12345FOR(i, 1, n + 1) &#123; dp[i][i] = 1; FOR(j, 1, i + 1) &#123; FOR(k, j, i + 1) &#123; dp[i][j] += dp[i - j][k] * A(k, j); // A 是排列数 需要预处理阶乘和阶乘的逆元 看起来复杂度是\(O(n^3)\)的，但是其实是\(O(n^3/6)\)，所以竟然没有超时？ 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (remove_const&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (remove_const&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const int maxn = 1200 + 5;const int MOD = 1E9 + 7;LL dp[maxn][maxn], n, a[maxn], l[maxn];LL invf[maxn], factor[maxn];LL quick_inverse(LL n, LL p) &#123; LL ret = 1; LL exponent = p - 2; for (LL i = exponent; i; i &gt;&gt;= 1, n = n * n % p) &#123; if (i &amp; 1) &#123; ret = ret * n % p; &#125; &#125; return ret;&#125;void get_factorial_inverse(LL n, LL p) &#123; factor[0] = 1; for (LL i = 1; i &lt;= n; ++i) &#123; factor[i] = i * factor[i - 1] % p; &#125; invf[n] = quick_inverse(factor[n], p); for (LL i = n-1; i &gt;= 0; --i) &#123; invf[i] = invf[i + 1] * (i + 1) % p; &#125;&#125;inline LL A(LL n, LL m) &#123; return factor[n] * invf[n - m] % MOD; &#125;int main() &#123; cin &gt;&gt; n; get_factorial_inverse(n, MOD); FOR(i, 0, n) scanf(&quot;%lld&quot;, &amp;a[i]); l[0] = 1; FOR(i, 1, n) if (a[i] &gt;= a[i - 1]) l[i] = l[i - 1] + 1; else l[i] = 1; FOR(i, 1, n + 1) &#123; FOR(j, 1, l[i - 1] + 1) &#123; if (i == l[i - 1]) dp[i][i] = 1; FOR(k, j, i - j + 1) dp[i][j] = (dp[i][j] + dp[i - j][k] * A(k, j)) % MOD; &#125; &#125; LL ans = 0; FOR(i, 1, l[n - 1] + 1) ans += dp[n][i]; cout &lt;&lt; ans % MOD &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - Fair Cut]]></title>
    <url>%2F2017%2F07%2F02%2FFair-Cut%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/fair-cut 题意 给 n 个数，分成 k 和 n - k 两组，使得两个组之间任意数对之差的绝对值之和最小。 题解 将问题转化为对于两组数每组内部元素两两之差的绝对值之和的和最大 排个序把绝对值去了 对于一组有 k 个元素有序的数，两两之差之和的值为 Sum[a[i] * (2i + k - 1), {i, 1, k}] dp[i][j] 表示第一组取 i 个数，第二组取 j 个数 （可以开成滚动数组） 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (remove_const&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (remove_const&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const int maxn = 3000 + 5;LL dp[maxn][maxn], n, k, a[maxn];int main() &#123; cin &gt;&gt; n &gt;&gt; k; FOR(i, 0, n) cin &gt;&gt; a[i]; sort(a, a + n); FOR(i, 0, k + 1) FOR(j, 0, n - k + 1) &#123; dp[i][j] = (i || j) ? -1E18 : 0; if (i) dp[i][j] = max(dp[i - 1][j] + a[i + j - 1] * (2 * i - k - 1), dp[i][j]); if (j) dp[i][j] = max(dp[i][j - 1] + a[i + j - 1] * (2 * j - (n - k) - 1), dp[i][j]); &#125; LL ans = -dp[k][n - k]; FOR(i, 0, n) ans += a[i] * (2 * i - n + 1); cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - Decibinary Numbers]]></title>
    <url>%2F2017%2F07%2F02%2FDecibinary-Numbers%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/prime-xor 题意 定义一种新的数值表示方法，每一位权值和二进制一样，但是每一位都可以是 0～9。问第 k 大的数是几（如果表示的数值一样大的话，再看做十进制比较）。 题解 dp[i][j] 表示 i 用不超过 j 位表示的方案数 先估计一下范围，但是开一维 dp 做会有这样的问题：表示同样的值的数没法按数值大小排序。 12345678910FOR(i, 2, 1000000) &#123; FOR(j, 0, 10) if ((i - j) % 2 == 0) dp[i] += dp[(i - j) / 2]; // cerr &lt;&lt; i &lt;&lt; ' ' &lt;&lt; dp[i] &lt;&lt; endl; s += dp[i]; if (s &gt; 1E16) &#123; cerr &lt;&lt; dp[i] &lt;&lt; ' ' &lt;&lt; i &lt;&lt; endl; // 114928788468 285112 break; &#125;&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (remove_const&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (remove_const&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const int maxn = 285112 + 5, maxm = 20;LL dp[maxn][maxm], s[maxn] = &#123;1&#125;;LL T, n;void go(LL n, LL rank, LL pos, bool leading) &#123; // cerr &lt;&lt; n &lt;&lt; ' ' &lt;&lt; rank &lt;&lt; ' ' &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; leading &lt;&lt; endl; if (!pos) return; assert(n &gt;= 0 &amp;&amp; rank &gt;= 0); LL t = 1 &lt;&lt; (pos - 1); LL s = 0; FOR(i, 0, 10) &#123; if (s + dp[n - i * t][pos - 1] &lt;= rank) s += dp[n - i * t][pos - 1]; else &#123; if (!leading || i) cout &lt;&lt; i; go(n - i * t, rank - s, pos - 1, leading &amp;&amp; !i); return; &#125; &#125;&#125;int main() &#123; FOR(i, 0, maxm) dp[0][i] = 1; FOR(i, 1, maxn) &#123; s[i] = s[i - 1] + dp[i - 1][maxm - 1]; FOR(j, 1, maxm) &#123; dp[i][j] = dp[i][j - 1]; LL t = 1 &lt;&lt; (j - 1); FOR(k, 1, 10) if (t * k &lt;= i) dp[i][j] += dp[i - t * k][j - 1]; else break; &#125; &#125; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; LL k = upper_bound(s, s + maxn, n) - s - 1; go(k, n - s[k], maxm, 1); puts(""); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - Prime XOR]]></title>
    <url>%2F2017%2F07%2F02%2FPrime-XOR%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/prime-xor 题意 给 n 个介于 3500 和 4500 之间的数，求不同子集（可以包含重复元素）的总数，使得子集异或和是质数。 题解 异或和的范围在 0～8191 之间，虽然 n 很大，但是每一个数的范围很小，因此可以依次处理 3500～4500 之间的每一个数。 dp[i][k] = dp[i - 1][k] * (a[i] / 2 + 1) + dp[i - 1][k ^ v[i]] * ((a[i] + 1) / 2) dp[i][k]表示前 i 个数异或和为 k 的方案数 a[i]记录 n 个数中 i 出现的次数，(a[i] / 2 + 1) 表示取偶数个，((a[i] + 1) / 2) 表示取奇数个 v[i]表示第 i 个数的值 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (__typeof(y) i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (__typeof(x) i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const int MOD = 1E9 + 7;const int maxn = 8192 + 10;bool p[maxn];int t, a[5000], T, n, u;LL dp[2][maxn];int main() &#123; for (int i = 2; i &lt; maxn; ++i) if (!p[i]) for (int j = i + i; j &lt; maxn; j += i) p[j] = 1; scanf("%d", &amp;T); while (T--) &#123; memset(dp, 0, sizeof dp); u = 0; dp[0][0] = 1; memset(a, 0, sizeof a); scanf("%d", &amp;n); FOR(i, 0, n) &#123; scanf("%d", &amp;t); ++a[t]; &#125; FOR(i, 3500, 4501) if (a[i]) &#123; u ^= 1; FOR(j, 0, 8192) dp[u][j] = ((1 + a[i] / 2) * dp[u ^ 1][j] + (a[i] + 1) / 2 * dp[u ^ 1][j ^ i]) % MOD; &#125; LL ans = 0; FOR(i, 2, 8192) if (!p[i]) ans += dp[u][i]; printf("%lld\n", ans % MOD); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 奇技淫巧]]></title>
    <url>%2F2017%2F06%2F17%2Fcpp-tricks%2F</url>
    <content type="text"><![CDATA[宏 12#define FOR(i, x, y) for (remove_const&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (remove_const&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i) GCC 的内置位运算函数 int __builtin_ffs (unsigned int x) Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero. int __builtin_clz (unsigned int x) Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined. int __builtin_ctz (unsigned int x) Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined. int __builtin_popcount (unsigned int x) Returns the number of 1-bits in x. int __builtin_parity (unsigned int x) Returns the parity of x, i.e. the number of 1-bits in x modulo 2. 在函数名后增加l或ll表示unsigned long int和unsigned long long int的对应版本。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法 - 博弈问题]]></title>
    <url>%2F2017%2F06%2F09%2FAlgorithms-Game-Theory%2F</url>
    <content type="text"><![CDATA[基本思想 游戏可以等效为一个有向图，每一个状态相当于图中的一个节点，而可能的状态转移是图中的边。如果必胜态的后继中存在必败态，而必败态的后继全是必胜态。 SG函数 \[ SG(u) = mex\{ SG(v)|u \to v \} \] 函数值为 0 代表必败态，不为 0 代表必胜态。（也就是说，0 只能转移到非 0，而非 0 一定能转移到 0。） 一个组合游戏的 SG 和等于所有子游戏的异或和。 ## Anti-SG 和 SJ 定理 Anti-SG 游戏： 走完最后一步的一方输，也就是说，SG 为 0 的局面不一定为终止局面。 SJ 定理： 对于 Anti-SG 游戏，如果游戏结束的条件是所有子游戏的 SG 值均为 0 时，那么先手必胜的条件是： SG 值不为零 xor 没有子游戏 SG 值大于1 Every-SG 每一个非终止状态的子游戏必须进行操作。 \[ step(v) = \begin{cases} 0, &amp; \text{$v$ 为终止状态} \\ max\{step(u)|SG(u)=0\}+1, &amp; \text{$SG(v)&gt;0$} \\ min\{step(u)\}, &amp; \text{$SG(v)=0$} \\ \end{cases} \] 先手必胜的充要条件：所有子游戏中最大的 step 值为奇数 Green Hackenbush 图上的删边游戏，过于复杂，自行搜索。 题目 解题思路 尽量将问题转换成 Nim 游戏计算 SG 和。 确定边界状态的 SG 值（不存在时为 -1） SG 计算过于复杂时打表找规律 zero-move 在 Nim 游戏的基础上增加一个规则，每一堆石子可以进行一次空操作（与玩家无关）。这道题看似同一次状态可以多次抵达，实则不然。同样多的石子，根据经历过空操作与否可以看做两个状态。 新的 SG 值： n 1 2 3 4 5 6 … SG 2 1 4 3 6 5 …]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Arch Linux - 大型攻略]]></title>
    <url>%2F2017%2F06%2F08%2FLinux-Another-Home%2F</url>
    <content type="text"><![CDATA[这篇文章的主要目的是记录我在使用 Linux 的过程中遇到的坑和相应的解决方案，次要目的是帮助读者快速构建一个舒适的 Linux 使用环境。后文的描述基于 Arch Linux 和 KDE 的方案，大部分也适用于 Kubuntu 用户。 发行版的选择 起初我选择的是 Ubuntu，其主要原因有如下几点： 用户的基数大，遇到问题能够方便得找到相应的解决方案 “网易云音乐”、“搜狗输入法”等应用提供的安装包是 Deb 包（ Ubuntu 可以直接安装，而 Debian 家族以外的发行版无法直接使用） 在使用 Ubuntu 将近一年后，我选择了 Arch Linux，它不仅拥有对我而言 Ubuntu 所有的优势，还提供了额外的便利： 官方仓库和用户软件仓库（AUR）提供了我想要的全部，包括上文中的“网易云音乐”和“搜狗输入法”。 拥有官方 Wiki，对于解决实际问题和学习 Linux 很有帮助 没有预装可有可无的软件包，用户拥有更大的选择余地 ## 安装 由于 Arch 的安装是在 CLI（命令行）下进行的，对于新用户可能有些困难。而在官方 Wiki 和网上教程的帮助下，完成安装应该也不成问题。 桌面环境的选择 在尝试过许多桌面环境后，我体会到了 KDE 的可贵。 可定制性远强于其他桌面环境。 有许多桌面控件可供选用（后文会有介绍）算法—— 博弈 可以很方便得修改 panel 的样式，于是我可以很轻松地将桌面从 Win10 风格切换至 OS X 风格。 可以在系统设置中修改动画效果 提供了虚拟桌面（Virtual desktops）和活动（Activities）的功能 可以修改主题、图标、窗口样式，而且默认主题十分美观 系统设置丰富 （有些东西没法通过图形界面设置的话就只能通过命令行或者修改配置文件来达到目的，十分不便） 有些集成的软件十分好用，比如文件管理器 dolphin，终端 konsole，便签 Knotes，快捷搜索 Lancelot（当然无论是什么桌面环境这些应用都可以做相应的替换，但是原生不容易出问题，体验也更为一致）。 缺点 集成了一些无用的软件，虽然可以在安装时进行筛选 设置中播放设备的选择太过繁琐 难以名状的 Bug，这个似乎很难避免，只要数量不多频率不高问题不大还是可以忍受一些的 KDE 的安装也十分便捷，参照 Wiki 即可，配合 SDDM 风味更佳。 常用软件 以下均为包名，可以直接安装（有些属于 AUR） chromium / firefox / google-chrome 浏览器三选一 shadowsocks-qt5 科学上网 wps-office &amp; ttf-wps-fonts WPS netease-cloud-music 网易云音乐 youdao-dict 有道词典 fcitx-sogoupinyin 搜狗拼音 calibre 电子书管理 atom 文本编辑器 redshift 屏幕色温调节 uget 多线程下载工具，支持磁链、种子（如果选用 aria2 作为后端，还需安装 aria2） vlc 视频播放器 p7zip-natspec &amp; unzip-natspec 使压缩包管理软件 Ark 解压（不是查看）zip、7z时避免出现中文文件名编码错误的问题 ntfs-3g 挂载 ntfs 分区（访问 Windows 分区或 ntfs 的移动硬盘） 以下软件给出安装方法 Mathematica 数学计算 Jetbrains IDE QQ的安装 解决方案：crossover 16 或 deepin-QQ with crossover 15 参考链接 crossover 16 有对多个版本的 QQ 的官方支持，建议购买正版，有试用期。 备选方案：crossover 15 的 crack 对 16 同样有效，需要的人自己找 Atom相关 项目的开发我还是建议使用 IDE，要让编辑器能拥有 IDE 的功能可能需要花大量的精力来改造。 #### apm Atom 的包管理器 apm 其实就是 npm，于是我们可以通过类似的方法为其设置镜像来加快下载速度。 12npm set registry https://registry.npm.taobao.orgapm config set registry https://registry.npm.taobao.org 插件 linter linter-gcc file-icons platformio-ide-terminal 桌面控件 Redshift Control 控制 redshift Netspeed Widget 网速监控 Event Calendar 带天气和倒计时的日历，可以和谷歌日历同步日程 Thermal Monitor 温度监测 PlayBar2 播放控制 Latte Dock 美观好用的 dock 额外 Wallpaper Switcher 不同虚拟桌面可以设置不同壁纸的特性作为 bug 在某一个版本后消失了，但许多用户认为这是一个好功能。于是一个 KDE 的开发人员按照承诺开发了这个工具提供了这个功能。 Active Window Control窗口在最大化后还会保留系统标题栏，而屏幕顶部还有一个 panel（如果和我一样把状态栏放到顶部），这样就会有两层，既不美观又浪费了空间。通过安装这个控件并且设置全屏隐藏标题栏后，可以达到和 OS X 同样的全屏后合并标题栏和系统状态栏的效果。 易用性 按键映射 创建文件～/.Xmodmap，fcitx 会自动读取并应用 xmodmap 的设置 以下是我使用的配置文件，将Caps_Lock修改为Ctrl，并交换`~ 和Esc 12345remove Lock = Caps_Lockkeysym Caps_Lock = Control_Ladd Control = Control_Lkeysym Escape = grave asciitilde grave asciitildekeysym grave = Escape 鼠标侧键 对于拥有鼠标侧键的用户而言，将这些侧键映射为常用快捷键（如浏览器标签页的切换、虚拟桌面的切换）可以带来极大的便捷。 我使用的软件是 xbindkeys。在~/.xbindkeysrc中修改配置，以下是我使用的配置 123456789101112&quot;xte &apos;keydown Super_L&apos; &apos;key Tab&apos; &apos;keyup Super_L&apos;&quot; b:8&quot;xte &apos;keydown Super_L&apos; &apos;key Tab&apos; &apos;keyup Super_L&apos;&quot; b:9# 侧键切换虚拟桌面&quot;xte &apos;keydown Control_L&apos; &apos;usleep 200000&apos; &apos;key Tab&apos; &apos;keyup Control_L&apos;&quot; b:7&quot;xte &apos;keydown Control_L&apos; &apos;keydown Shift_L&apos; &apos;usleep 200000&apos; &apos;key Tab&apos; &apos;keyup Shift_L&apos; &apos;keyup Control_L&apos;&quot; b:6# 水平滚轮切换浏览器标签页，延迟是为了防止切换过快 与 Google Drive 文件同步 使用grive，由于对应 GUI 工具grive-tools不支持代理，因此无法使用。 替代方案：在系统设置中添加计划任务进行定时同步。 参考文章 https://blog.hanschen.org/2009/10/13/mouse-shortcuts-with-xbindkeys/ https://wiki.archlinux.org/index.php/Mouse_buttons#xvkbd_and_xbindkeys ### 触控板手势 对于长期使用触控板的用户来说，多指手势可以用来替代许多快捷键。 我使用的软件是 Touchegg以及对应的 GUI 配置工具 touchegg-gce-git Tips dolphin 中Alt + .切换是否显示隐藏文件 更新 kernel 之后不要忘记重启，]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[你好，世界！]]></content>
  </entry>
</search>