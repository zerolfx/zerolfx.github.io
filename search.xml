<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【题解】HackerRank - Unique Colors]]></title>
    <url>%2F2017%2F11%2F01%2FUnique-Colors%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/unique-colors 题意 给定一棵树，树上每一个点都有一种颜色。定义一条路径的价值为路径上不同颜色的点的个数。对于树上的每个结点，输出从该结点出发的所有路径的价值之和。 题解 官方题解是用树上点分治，但是很遗憾题解看不懂。 神奇的是这道题和 2017 年多校第一场的某题极度相似（HDU 6035）。 多校官方题解： 单独考虑每一种颜色，答案就是对于每种颜色至少经过一次这种的路径条数之和。反过来思考只需要求有多少条路径没有经过这种颜色即可。直接做可以采用虚树的思想（不用真正建出来），对每种颜色的点按照 dfs 序列排个序，就能求出这些点把原来的树划分成的块的大小。这个过程实际上可以直接一次 dfs 求出。 每种颜色分开考虑，计算每种颜色的贡献。 考虑问题的反面，某种颜色没有贡献给一条路径等价于路径的两个端点在同一个没有该种颜色的联通块中。也就是说，对于每一块没有这种颜色的树上联通块，联通块中所有点的答案减去联通块的大小。 难点在于对于每种颜色，复杂度不能与整棵树的大小相关，而是与该颜色结点个数相关。但是访问结点以及递归必须按顺序进行，于是需要按照 dfs序 进行递归。这就是多校题解中提到的虚树思想，当然这道题不用把树建出来。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define FOR(i, x, y) for (decay&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (decay&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)#ifdef zerol#define dbg(args...) do &#123; cout &lt;&lt; "\033[32;1m" &lt;&lt; #args&lt;&lt; " -&gt; "; err(args); &#125; while (0)#else#define dbg(...)#endifvoid err() &#123; cout &lt;&lt; "\033[39;0m" &lt;&lt; endl; &#125;template&lt;typename T, typename... Args&gt;void err(T a, Args... args) &#123; cout &lt;&lt; a &lt;&lt; ' '; err(args...); &#125;// -----------------------------------------------------------------------------const int maxn = 1E5 + 100, maxc = 1E5 + 100;int c[maxn], in[maxn], out[maxn], sz[maxn], pa[maxn];vector&lt;int&gt; G[maxn], C[maxn];int n, clk = 0;struct BIT &#123; LL c[maxn]; inline int lowbit(int x) &#123; return x &amp; -x; &#125; void add(int x, int k) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) c[i] += k; &#125; LL sum(int x) &#123; LL ret = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret; &#125; void add(int l, int r, int v) &#123; add(l, v); add(r + 1, -v); &#125;&#125; bit;void init_dfs(int u, int fa) &#123; in[u] = clk++; C[c[u]].push_back(u); pa[u] = fa; sz[u] = 1; for (int v: G[u]) &#123; if (v == fa) continue; init_dfs(v, u); sz[u] += sz[v]; &#125; out[u] = clk - 1;&#125;void go(const vector&lt;int&gt;&amp; V, int&amp; k) &#123; vector&lt;int&gt; nxt; int u = V[k]; for (int v: G[u]) &#123; if (v == pa[u]) continue; int num = sz[v]; nxt.clear(); while (k + 1 &lt; V.size()) &#123; int to = V[k + 1]; if (in[to] &lt;= out[v]) &#123; nxt.push_back(to); num -= sz[to]; go(V, ++k); &#125; else break; &#125; bit.add(in[v], out[v], num); for (int to: nxt) bit.add(in[to], out[to], -num); &#125;&#125;int main() &#123;#ifdef zerol freopen("in", "r", stdin);#endif cin &gt;&gt; n; FOR (i, 1, maxc) C[i].push_back(0); G[0].push_back(1); pa[1] = 0; c[0] = 0; FOR (i, 1, n + 1) scanf("%d", &amp;c[i]); FOR (_, 1, n) &#123; static int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; init_dfs(0, -1); int tmp; LL color_cnt = 0; FOR (k, 1, maxc) &#123; if (C[k].size() == 1) continue; color_cnt++; go(C[k], tmp = 0); &#125; FOR (i, 1, n + 1) printf("%lld\n", color_cnt * n - bit.sum(in[i]));&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>虚树</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 线段树]]></title>
    <url>%2F2017%2F10%2F29%2FSegment-Tree%2F</url>
    <content type="text"><![CDATA[代码详见模板库。模板题 EOJ 3389-3393。 Q: 要不要把 n 补成 2 的幂？ A: 这个无所谓，但如果要写成自底向上，那么还是需要的，否则无法直接定位叶节点。 Q: pushdown 之后要不要立即 maintain？ A: 不用立即 maintain，但迟早是要的。但是立即 maintain 很可能会重复 maintain，增加超时风险。 Q:query 的时候要不要 pushdown？ A: 如果不要的话，查询时应该把之前访问到的结点的标签的效果累加起来，并作为参数递归下去。如果要的话，代码会更加具有普适性（比如 treap 只能选择 pushdown 标签，因为结点之间相对位置会改变）。 Q: maintain 的时候是否考虑当前结点的标签？ A: 都可以。如果考虑了，那么查询的时候就不要考虑当前结点的标签了，反之亦然。 Q: query 的时候先考虑 set 标签还是先考虑查询区间包含当前区间？ A: 都可以，但是先考虑 set 会快一些。 Q: 根节点是 0 还是 1？ A: 都可以，但好像 1 比较符合人性。 Q: 听说空间开三倍就够了？ A: 那可能就 GG 了，实测 4 倍是必要的。 其他注意事项： maintain 函数要写得保证即便是重复调用也不会出错。 pushdown 子节点必须 maintain，尤其是那个没有递归下去的子节点。 打完 set 标记后 add 标记必须清空。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - Counting On a Tree]]></title>
    <url>%2F2017%2F10%2F28%2FCounting-On-a-Tree%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/counting-on-a-tree 题意 给一棵树，树上的每一个点都有一个数字，询问对于给定的两条树上路径，有多少对不同的且分别属于两条路径的点满足对应数字相等。 题解 题目要求的是不同的点，先不考虑这个条件，最后减去路径交的长度即可。 树上的任意路径可以分解成两条链（后文称之为规范链），使得每条链中的一个点是另一个点的祖先，这样便于计数。 设路径 x 和 y 分别分解成 x1, x2 和 y1, y2，最后的答案就是把 (x1, y1), (x2, y1), (x1, y2), (x2, y2) 的答案加起来 对于每一种颜色，按是否大于点数量的平方根，分为两种情况 如果颜色数量大于 SQRT 对于每一种这样的颜色，跑一边 dfs，计算出每个点到根的路径上有多少这种颜色的点（前缀和）。 然后对于每一条规范链，可以做差得到链上这种颜色的点有几个。 乘起来就是两条规范链的同色点对数了。 如果颜色数量不大于 SQRT，设这样的颜色属于 集合c。 首先预处理时记录 dfs 序 在 dfs 过程中维护一个树状数组，记录的是树上的每一个点到根的路径上 颜色属于集合x 的点的个数，集合 x 为当前点到根的路径上出现过得所有属于 集合c 的颜色（可重复）。 访问一个结点时，把所有相同颜色的点对应的 dfs序 区间 +1 即可。 注意需要对询问预处理，分解询问分发到每个结点 注意由于 dfs 时树状数组状态要回溯，所以要回滚操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define FOR(i, x, y) for (decay&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (decay&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)#ifdef zerol#define dbg(args...) do &#123; cout &lt;&lt; "\033[32;1m" &lt;&lt; #args&lt;&lt; " -&gt; "; err(args); &#125; while (0)#else#define dbg(...)#endifvoid err() &#123; cout &lt;&lt; "\033[39;0m" &lt;&lt; endl; &#125;template&lt;typename T, typename... Args&gt;void err(T a, Args... args) &#123; cout &lt;&lt; a &lt;&lt; ' '; err(args...); &#125;// -----------------------------------------------------------------------------const int maxn = 1E5 + 100;const int SQRT = 100;struct L &#123; int bt, tp;&#125;;struct Q &#123; L l; int sgn, idx;&#125;;vector&lt;Q&gt; qq[maxn];L query[maxn][4];int n, clk = 1;int in[maxn], out[maxn], dep[maxn], pa[maxn][20], a[maxn], cnt[maxn];LL ans[maxn];vector&lt;int&gt; G[maxn];vector&lt;int&gt; C[maxn];struct BIT &#123; int c[maxn]; void init() &#123; memset(c, 0, sizeof c); &#125; inline int lowbit(int x) &#123; return x &amp; -x; &#125; void add(int x, int v) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) c[i] += v; &#125; int sum(int x) &#123; int ret = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret; &#125; void add(int l, int r, int v) &#123; add(l, v); add(r + 1, -v); &#125;&#125; bit;void dfs(int u, int fa, int d) &#123; in[u] = clk++; pa[u][0] = fa; dep[u] = d; for (int v: G[u]) if (v != fa) dfs(v, u, d + 1); out[u] = clk - 1;&#125;void lca_init() &#123; FOR (x, 1, 20) FOR (i, 1, n + 1) pa[i][x] = pa[pa[i][x - 1]][x - 1];&#125;inline int pp(int x) &#123; if (x == 1) return 0; return pa[x][0];&#125;int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); FORD (i, 19, -1) &#123; int uu = pa[u][i]; if (dep[uu] &gt;= dep[v]) u = uu; &#125; if (u == v) return u; FORD (i, 19, -1) &#123; int uu = pa[u][i], vv = pa[v][i]; if (uu != vv) &#123; u = uu; v = vv; &#125; &#125; return pp(u);&#125;int intersection(int x, int y, int xx, int yy) &#123; int t[4] = &#123;lca(x, xx), lca(x, yy), lca(y, xx), lca(y, yy)&#125;; sort(t, t + 4); int r = lca(x, y), rr = lca(xx, yy); if (dep[t[0]] &lt; min(dep[r], dep[rr]) || dep[t[2]] &lt; max(dep[r], dep[rr])) return 0; int tt = lca(t[2], t[3]); int ret = 1 + dep[t[2]] + dep[t[3]] - dep[tt] * 2; return ret;&#125;void dfs_calc(int u) &#123; int c = a[u]; if (C[c].size() &lt; SQRT) for (int v: C[c]) bit.add(in[v], out[v], 1); for (Q&amp; q: qq[u])pingfangfenge ans[q.idx] += q.sgn * (bit.sum(in[q.l.bt]) - bit.sum(in[q.l.tp])); for (int v: G[u]) if (v != pp(u)) dfs_calc(v); if (C[c].size() &lt; SQRT) for (int v: C[c]) bit.add(in[v], out[v], -1);&#125;void dfs_cnt(int u, int c, int s) &#123; if (a[u] == c) ++s; cnt[u] = s; for (int v: G[u]) if (v != pp(u)) dfs_cnt(v, c, s);&#125;int main() &#123;#ifdef zerol freopen("in", "r", stdin);#endif int q_sz, mp_sz = 0; map&lt;int, int&gt; mp; cin &gt;&gt; n &gt;&gt; q_sz; FOR (i, 1, n + 1) &#123; scanf("%d", &amp;a[i]); auto it = mp.find(a[i]); if (it == mp.end()) a[i] = mp[a[i]] = mp_sz++; else a[i] = it-&gt;second; C[a[i]].push_back(i); &#125; FOR (_, 1, n) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 1, 1); lca_init(); FOR (i, 0, q_sz) &#123; int x, y, xx, yy; scanf("%d%d%d%d", &amp;x, &amp;y, &amp;xx, &amp;yy); ans[i] -= intersection(x, y, xx, yy); int z = lca(x, y), zz = lca(xx, yy); query[i][0] = &#123;x, z&#125;; query[i][1] = &#123;y, pp(z)&#125;; query[i][2] = &#123;xx, zz&#125;; query[i][3] = &#123;yy, pp(zz)&#125;; FOR (p, 0, 2) FOR (q, 2, 4) &#123; qq[query[i][p].bt].push_back(&#123;query[i][q], 1, i&#125;); qq[query[i][p].tp].push_back(&#123;query[i][q], -1, i&#125;); &#125; &#125; FOR (i, 0, mp_sz) &#123; if (C[i].size() &lt; SQRT) continue; memset(cnt, 0, sizeof cnt); dfs_cnt(1, i, 0); FOR (j, 0, q_sz) &#123; int c1 = 0, c2 = 0; FOR (k, 0, 2) c1 += cnt[query[j][k].bt] - cnt[query[j][k].tp]; FOR (k, 2, 4) c2 += cnt[query[j][k].bt] - cnt[query[j][k].tp]; ans[j] += c1 * c2; &#125; &#125; dfs_calc(1); FOR (i, 0, q_sz) printf("%lld\n", ans[i]);&#125; 题解（假） 这个题解是官方的 editorial，但是我的实现会超时，但答案是对的。另外，这个算法时在线的，但难写很多，常数也大很多。总结一下，这个算法假得很，分块和不分块差不多。 对于询问的路径，剖分成若干条链。 把树上点值按树链剖分的下标数组进行平方分割。 预处理一个 n × sqrt(n) 的数组，表示第 i 个元素在第 j 块中出现了几次。 对于完整的块和连续的一段可以做到 O(1) 查询 对于零散的，数组大小不超过 SQRT * log(n)，进行桶排线性查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define FOR(i, x, y) for (decay&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (decay&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)#ifdef zerol#define dbg(args...) do &#123; cout &lt;&lt; "\033[32;1m" &lt;&lt; #args&lt;&lt; " -&gt; "; err(args); &#125; while (0)#else#define dbg(...)#endifvoid err() &#123; cout &lt;&lt; "\033[39;0m" &lt;&lt; endl; &#125;template&lt;typename T, typename... Args&gt;void err(T a, Args... args) &#123; cout &lt;&lt; a &lt;&lt; ' '; err(args...); &#125;// -----------------------------------------------------------------------------const int maxn = 1E5 + 10;const int M = 300;const int B = 334;int son[maxn], sz[maxn], fa[maxn], idx[maxn], dep[maxn], top[maxn];int w[maxn], a[maxn], c[maxn][B + 2];vector&lt;int&gt; G[maxn];int clk;void predfs(int u, int d) &#123; dep[u] = d; int&amp; maxs = son[u] = -1; sz[u] = 1; for (int v: G[u]) if (v != fa[u]) &#123; fa[v] = u; predfs(v, d + 1); sz[u] += sz[v]; if (maxs == -1 || son[maxs] &lt; son[v]) maxs = v; &#125;&#125;void dfs(int u, int tp) &#123; top[u] = tp; idx[u] = ++clk; w[clk - 1] = a[u]; if (son[u] == -1) return; dfs(son[u], tp); for (int v: G[u]) if (v != fa[u] &amp;&amp; v != son[u]) dfs(v, v);&#125;inline int sum(int l, int r, int bl, int br) &#123; l--; r--; bl--; br--; int ret = c[r][br]; if (l) ret -= c[l - 1][br]; if (bl) ret -= c[r][bl - 1]; if (l &amp;&amp; bl) ret += c[l - 1][bl - 1]; return ret;&#125;struct P &#123; int l, r;&#125;;typedef vector&lt;P&gt; VI;void divide(int l, int r, VI&amp; b, VI&amp; t) &#123; int x = l / M, y = r / M; if (x == y) t.push_back(&#123;l, r&#125;); else &#123; t.push_back(&#123;l, (x + 1) * M - 1&#125;); t.push_back(&#123;y * M, r&#125;); if (x + 1 &lt;= y - 1) b.push_back(&#123;x + 1, y - 1&#125;); &#125;&#125;void query(int u, int v, VI&amp; b, VI&amp; t) &#123; b.clear(); t.clear(); int uu = top[u], vv = top[v]; while (uu != vv) &#123; if (dep[uu] &lt; dep[vv]) &#123; swap(uu, vv); swap(u, v); &#125; divide(idx[uu], idx[u], b, t); u = fa[uu]; uu = top[u]; &#125;; if (dep[u] &lt; dep[v]) &#123; swap(uu, vv); swap(u, v); &#125; divide(idx[v], idx[u], b, t);&#125;int go(VI&amp; b, VI&amp; t, VI&amp; bb, VI&amp; tt) &#123; int ans = 0; for (P&amp; p: b) for (P&amp; q: bb) &#123; int l = p.l * M, r = (p.r + 1) * M - 1; ans += sum(l, r, q.l, q.r); &#125; for (P&amp; p: b) for (P&amp; q: tt) ans += sum(q.l, q.r, p.l, p.r); for (P&amp; p: bb) for (P&amp; q: t) ans += sum(q.l, q.r, p.l, p.r); static int cnt[maxn]; memset(cnt, 0, sizeof cnt); for (P&amp; p: t) FOR (i, p.l, p.r + 1) cnt[w[i - 1]]++; for (P&amp; p: tt) FOR (i, p.l, p.r + 1) ans += cnt[w[i - 1]]; return ans;&#125;int lca(int u, int v) &#123; int uu = top[u], vv = top[v]; while (uu != vv) &#123; if (dep[uu] &lt; dep[vv]) &#123; swap(u, v); swap(uu, vv); &#125; u = fa[uu]; uu = top[u]; &#125; if (dep[u] &lt; dep[v]) return u; else return v;&#125;int intersection(int x, int y, int xx, int yy) &#123; int t[4] = &#123;lca(x, xx), lca(x, yy), lca(y, xx), lca(y, yy)&#125;; sort(t, t + 4); int r = lca(x, y), rr = lca(xx, yy); if (dep[t[0]] &lt; min(dep[r], dep[rr]) || dep[t[2]] &lt; max(dep[r], dep[rr])) return 0; int tt = lca(t[2], t[3]); int ret = 1 + dep[t[2]] + dep[t[3]] - dep[tt] * 2; return ret;&#125;int cnt[maxn];int main() &#123; int n, Q, u, v, ttt = 0; map&lt;int, int&gt; mp; cin &gt;&gt; n &gt;&gt; Q; FOR (i, 1, n + 1) &#123; scanf("%d", &amp;a[i]); auto it = mp.find(a[i]); if (it == mp.end()) a[i] = mp[a[i]] = ++ttt; else a[i] = it-&gt;second; &#125; FOR (i, 1, n) &#123; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; predfs(1, 1); dfs(1, 1); FOR (b, 0, B) &#123; memset(cnt, 0, sizeof cnt); FOR (i, b * M, (b + 1) * M) if (i &gt;= n) break; else cnt[w[i]]++; FOR (i, 0, n) c[i][b] = cnt[w[i]]; &#125; FOR (i, 0, n) FOR (b, 0, B) &#123; int&amp; t = c[i][b]; if (i) t += c[i - 1][b]; if (b) t += c[i][b - 1]; if (i &amp;&amp; b) t -= c[i - 1][b - 1]; &#125; while (Q--) &#123; static int x, y, xx, yy; scanf("%d%d%d%d", &amp;x, &amp;y, &amp;xx, &amp;yy); VI b, t, bb, tt; query(x, y, b, t); query(xx, yy, bb, tt); printf("%d\n", go(b, t, bb, tt) - intersection(x, y, xx, yy)); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 二进制分组]]></title>
    <url>%2F2017%2F08%2F04%2Fgroup-by-binary%2F</url>
    <content type="text"><![CDATA[资料 具体见 2013 年集训队论文《浅谈数据结构题的几个非经典解法》（作者：许昊然）。 为什么 题目要求支持修改和查询操作。 但是你只有一种不支持修改的算法，往往是通过预处理来支持快速查询操作。 如果直接使用这种算法，可能要预处理很慢却要常常进行，查询很快却没几个，时间复杂度分配很不合理。 于是你想到，可以通过分块使时间复杂度变得均匀合理。就是把每 \(\sqrt n\) 个修改操作（假设修改操作共 \(n\) 个）分为一组，然后每次需要预处理的长度上限就变小了，作为代价，增加了查询的时间。 二进制分组是一种更为优秀的分组策略（具体和预处理复杂度和查询复杂度相关）。如果当前有 k 个修改操作，会按照 2 的幂将 k 分解从大到小的若干组。如果增加一个操作，分组的变化通过暴力删除和重建进行（当然如果可以合并的话那就只需要合并了）。(如 5 = 4 + 1, 6 = 4 + 2，从 5 增加到 6 就把原来那个大小为 1 的组删了，再将原来最后一个和新增加的那一个建一个大小为 2 的组) 复杂度： 单次查询复杂度 \(\times \log n\)，毕竟最多只有 \(\log n\) 组嘛。 总的预处理复杂度是单次的 \(\log n\) 倍，具体证明见论文。 限制 如果这不是一道强制在线题，我大可以选择时间分治。 如果有支持在线的算法或数据结构，我就没有必要用 log 的代价把在线换成离线。 要求修改操作的贡献可以任意次序累加。 例题 不存在的。这个算法想法很不错，不过很可能用不上。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ACGN]]></title>
    <url>%2F2017%2F08%2F03%2FACGN%2F</url>
    <content type="text"><![CDATA[本文的目的是记录一些对于 ACGN 作品的感想，而所谓感想，难免带有强烈的主观色彩，勿较真。 大坑待填。 前言 心态 我觉得通常有两种心态。 其一，作品之外。带着批判、审视的眼光去看作品，于是便能够描述出作品的优劣之处，给予合理的评价。 其二，作品之内。尽量使自己代入作者所构建的世界中，并为人物的遭遇或悲或喜，甚至可能在看完之后久久不能释怀。 我更倾向于选择后者，因为这样我才能够感受作者想要展现的一切，想要表达的一切，也算是对作者的一种尊重。 设定 我觉得一部优秀的作品应该有优秀的设定，最好能够令人耳目一新。在我看来合理性是建立在设定上的，因此即便是设定离现实很遥远，但只要人物的行为符合设定下的情境和心理，我便认为这是合理的。倘若产生了不合理、突兀的情节，又用补充新的设定去弥补，那真是太糟糕了。 过往 情节的起源、人物的动机常常源于人物童年时的经历（替弗洛伊德深表赞成）。 从这里寻求什么 观看顺序 刚入坑时的感受与多年以后肯定有所不同。也许眼光更高，对作品的要求更为苛刻，也许以前令我耳目一新的情节就变为了烂大街的桥段。 动画 A+ 命运石之门 (Steins;Gate)【A+】 魔法少女小圆【A+】 编剧：虚渊玄 沙耶香，为他人祈愿，想成为正义的伙伴。那么她最终得到了她想要的东西了吗，又是否会后悔？ 这个角色最令我心痛，看着她从美好（自私）的祈愿走向注定的灭亡。一周目时觉得她有些不可理喻，伤害了自己，还伤害了朋友，而二周目后才发现，她可能是最为真实的那个角色。 晓美焰，为了小圆一次次轮回，曾经的愿望，逐渐成为模糊不清的结局，也许这一次，就是最后一次了吧。 从动画一开始，就展现了小圆所拥有的幸福。所谓幸福，着实是令人羡慕的事物。这样的她，本没有成为魔法少女的理由。 弹丸论破 (弹丸轮舞)【A+】 Fate/Zero (FZ)【A+】 同名小说动画化，因为作者是虚渊玄，所以剧情上一定很精彩。事实上小说和动画都很不错。 动画中的许多登场人物中，最后得到救赎的寥寥无几。御主的愿望和英灵的夙愿，倘若想要完成自己的心愿就必须牺牲别人的心愿，因而注定充斥着悲剧。 正义是什么？是不是应该为了大部分人的生而舍弃少部分人？ Fate/stay night [Unlimited Blade Works] (FSN UBW篇)【A+】 冰菓【A+】 死亡笔记 (Death Note)【A+】 A Another (替身) 【A】 当得知这部动画是由 绫辻行人 的作品改编之时，我便立即找小说来看。那么首先介绍一下绫辻行人。 绫辻行人的推理作品我一直很喜欢，新本格推理也令我着迷。一定要说好在哪里的话，我觉得氛围的营造十分出色。但如果你十分追求推理作品解答的合理、线索的公平，那可能就会感到失望了。推荐路线《十角馆杀人预告》-&gt;《雾越邸杀人事件》-&gt; 《钟表馆幽灵》 《Another》在我看来不是轻小说（这个判断不会错的），所以改变成动画令我感到有些意外（其实还改编成漫画）。（也许是因为故事发生在小城市的校园中，剧情又从一开始就引人入胜，很像是轻小说的架构？） 这部动画成为禁片的缘故我觉得是因为血腥，画面可能比文字震撼多了。其实作者能写出那么血腥的画面我一点也不意外，因为我看过作者的另一部作品《杀人鬼》（极不推荐，光是恐怖真的没有意思）。 看完小说后，我试着去看动画，但由于女主形象和我看小说时想象出来的相差甚远，便放弃了。看完动画是很久之后的事了，那时小说中的情节只能记得大概。 超现实，甚至称得上是灵异。就凭这一点就意味着这部作品只会被少部分人喜爱。 如果从悬疑来看，这确实是出色的作品。 绫辻行人后来写了《Another S》（替身S）。与《Another》的关联并不大，不推荐阅读。（如果实在喜欢《Another》这部作品，也不妨阅读一下这个，顶多看完有点后悔。） 罪恶王冠【A】 GOSICK【A】 Angel Beats! (天使的心跳)【A】 天才麻将少女【A】 刀剑神域【A】 A- Re：从零开始的异世界生活 (Re:0)【A-】 CLANNAD【A-】 四月是你的谎言【A-】 B 编舟记【B】 狐妖小红娘【B】 小林家的龙女仆【B】 埃罗芒阿老师 (黄漫老师)【B】 混沌之子 (Chaos;Head)【B】 特指动画 C 混沌之脑 (Chaos;Child)【C】 特指动画 时钟机关之星【C】 小说 这里只列举了一部分我看过的轻小说。 野村美月的作品 文学小女【???】 光在地球之时【??】 女装家教 (女装皇家教师)【??】 陆与千星~发送世界的少年与别墅的少女【?】 动画化的作品 刀剑神域【A-】 机巧少女不会受伤【B】 精灵使的剑舞【B】 绯弹的亚里亚【B】 约会大作战 (DATE A LIFE)【B】 游戏 弹丸轮舞 2【A+】 漫画 端脑【A】 备注 文中的推荐路线很可能并没有把作者最优秀的作品放在最前面，因为考虑到作品的长度和难度，以及对该作者作品的优秀程度信任的累积过程。 评价，其中 A 代表我会向别人推荐这部作品。 A+: 我认为很出色，而且是多数人都会喜欢的作品。 A: 我认为很出色，但可能只有少部分人会喜欢的作品。 A-: 大多数人都会喜欢，但我觉得没那么出色的作品。 B: 我认为一般，或者我不会推荐给别人看的作品。 C: 我认为糟糕，而且会劝别人不要看的作品。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法 - 整体二分]]></title>
    <url>%2F2017%2F08%2F03%2Fdivide-and-conquer%2F</url>
    <content type="text"><![CDATA[资料 具体见 2013 年集训队论文《浅谈数据结构题的几个非经典解法》（作者：许昊然）。 本文假设读者已经读过这篇论文中整体二分的部分。 限制 需要离线 可以二分答案 修改操作，要求对于一次查询，前面的修改操作可以交换顺序而不影响查询结果 贡献可以累加 注意将操作（包括询问）分离到两个新的答案区间这个过程的复杂度应该和操作数的个数相关，而不能和以下两项相关： 总的区间（就是最初的答案区间） 尤其是序列总长，通常指的是询问区间的长度 例题 静态区间第k大 题目：poj 2104, hdu 2665, EOJ 3315 经典题。给出 n 个数，询问区间内第k大的数。通常做法是主席树。 整体二分答案 目标：对于在答案区间 [l, r] 内的询问，分发到 [l, mid] 和 [mid + 1, r]，这个过程要求时间复杂度与询问个数或者答案区间长度相关而不能与 n 有关。 筛选出 n 个数中大小在 [mid + 1, r] 之间的数的位置，通过二分查找计算这些数有几个落在每个询问的区间内，存到临时答案数组 tmp_ans 中。 对于询问 q[i], 如果 k-1 &lt; tmp_ans[i] + q[i].cur，说明答案落在 [mid + 1, r] 中，反之，则落在 [l, mid] 中，由于大于 mid 的数的贡献不变，所以存在 q[i].cur 中，之后就不需要考虑 大于 mid 的数了。 至此，成功划分为子问题。 复杂度 \(O((N + Q)\log n\log C)\)，\(C\) 是数值范围 实际上用整体二分的时间消耗和主席树很接近，代码长度也没有优势，但是很省空间。 代码 (EOJ 3315): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (decay&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (decay&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const int MAX = 1E9 + 10;const int maxn = 1E5 + 100;struct Q &#123; int l, r, k, cur, ans;&#125;;struct P &#123; int id, v; bool operator &lt; (const P&amp; rhs) const &#123; return v &lt; rhs.v; &#125;&#125;;Q query[maxn];P p[maxn];int n, m, t, pos[maxn], pos_sz, tmp_ans[maxn];void go(const vector&lt;Q*&gt;&amp; q, int l, int r) &#123; if (q.empty()) return; if (l == r) &#123; FOR (i, 0, q.size()) q[i]-&gt;ans = l; return; &#125; int mid = l + ((r - l) &gt;&gt; 1); pos_sz = 0; FOR (it, upper_bound(p, p + n, P&#123;0, mid&#125;), upper_bound(p, p + n, P&#123;0, r&#125;)) pos[pos_sz++] = it-&gt;id; sort(pos, pos + pos_sz); FOR (i, 0, q.size()) tmp_ans[i] = upper_bound(pos, pos + pos_sz, q[i]-&gt;r) - lower_bound(pos, pos + pos_sz, q[i]-&gt;l); vector&lt;Q*&gt; qL, qR; FOR (i, 0, q.size()) &#123; if (q[i]-&gt;k - 1 &lt; q[i]-&gt;cur + tmp_ans[i]) &#123; qR.push_back(q[i]); &#125; else &#123; qL.push_back(q[i]); q[i]-&gt;cur += tmp_ans[i]; &#125; &#125; go(qL, l, mid); go(qR, mid + 1, r);&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; FOR (i, 0, n) &#123; scanf("%d", &amp;t); p[i].v = t; p[i].id = i + 1; &#125; sort(p, p + n); vector&lt;Q*&gt; q; FOR (i, 0, m) &#123; scanf("%d%d%d", &amp;query[i].l, &amp;query[i].r, &amp;query[i].k); query[i].cur = 0; q.push_back(&amp;query[i]); &#125; go(q, -MAX, MAX); FOR (i, 0, m) printf("%d\n", q[i]-&gt;ans);&#125; 动态区间第k大 题目：hdu 5412。 与之前的题目相比，额外支持一个操作，修改一个位置上的数。 将修改操作视为删除一个数后插入一个数，一开始的初始状态看做进行了 n 次插入操作。 无论是查询操作还是修改操作，都需要分发到对应子区间内。 利用树状数组来保证单次的复杂度仅与待分发的操作数个数相关。 树状数组使用后进行还原，避免了\(O(n)\)的清空操作 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (decay&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (decay&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const int maxn = 1E5 + 10;const int MAX = 1E9 + 10;struct Q &#123; // tp = 0 -&gt; query, tp = 1 -&gt; modify int tp, pos, d, l, r, k, cur, ans;&#125;;int a[maxn], n, m, q_n, t, l, r, k, pos, c[maxn], tmp_ans[maxn];Q q[maxn &lt;&lt; 1];inline int lowbit(int x) &#123; return x &amp; -x; &#125;void add(int x, int k) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) c[i] += k;&#125;int sum(int x) &#123; int ret = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret;&#125;void go(const vector&lt;Q*&gt;&amp; q, int l, int r) &#123; cerr &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; if (q.empty()) return; if (l == r) &#123; FOR (i, 0, q.size()) q[i]-&gt;ans = l; return; &#125; int mid = l + ((r - l) &gt;&gt; 1); FOR (i, 0, q.size()) if (q[i]-&gt;tp &amp;&amp; abs(q[i]-&gt;d) &lt;= mid) add(q[i]-&gt;pos, q[i]-&gt;d / abs(q[i]-&gt; d)); else if (!q[i]-&gt;tp) tmp_ans[i] = sum(q[i]-&gt;r) - sum(q[i]-&gt;l - 1); FOR (i, 0, q.size()) if (q[i]-&gt;tp &amp;&amp; abs(q[i]-&gt;d) &lt;= mid) add(q[i]-&gt;pos, -q[i]-&gt;d / abs(q[i]-&gt; d)); vector&lt;Q*&gt; qL, qR; FOR (i, 0, q.size()) if (!q[i]-&gt;tp) &#123; if (q[i]-&gt; k &gt; tmp_ans[i] + q[i]-&gt;cur) &#123; qR.push_back(q[i]); q[i]-&gt;cur += tmp_ans[i]; &#125; else &#123; qL.push_back(q[i]); &#125; &#125; else &#123; if (abs(q[i]-&gt;d) &lt;= mid) qL.push_back(q[i]); else qR.push_back(q[i]); &#125; go(qL, l, mid); go(qR, mid + 1, r);&#125;int main() &#123; cin &gt;&gt; n; FOR (i, 1, n + 1) &#123; scanf("%d", &amp;a[i]); q[m++] = Q&#123;1, i, a[i], -1, -1, -1, -1, -1&#125;; &#125; cin &gt;&gt; q_n; FOR (i, 0, q_n) &#123; scanf("%d", &amp;t); if (t == 2) &#123; scanf("%d%d%d", &amp;l, &amp;r, &amp;k); q[m++] = Q&#123;0, -1, -1, l, r, k, 0, 0&#125;; &#125; else &#123; scanf("%d", &amp;pos); q[m++] = Q&#123;1, pos, -a[pos], -1, -1, -1, -1, -1&#125;; scanf("%d", &amp;a[pos]); q[m++] = Q&#123;1, pos, a[pos], -1, -1, -1, -1, -1&#125;; &#125; &#125; vector&lt;Q*&gt; query; query.resize(m); FOR (i, 0, m) query[i] = &amp;q[i]; go(query, 1, MAX); FOR (i, 0, m) if (!q[i].tp) printf("%d\n", q[i].ans);&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - Recurrent on a Tree]]></title>
    <url>%2F2017%2F07%2F20%2FRecurrent-on-a-Tree%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/contests/w34/challenges/recurrent-on-tree 题意 给一棵树，每个点有一个值。求任意两个顶点（可以相同）路径上的值的和经过 f 函数后的和。f(x) 是斐波那契数列第 x 项。 题解 斐波那契数列的某一项可以通过矩阵快速幂求得。与之类似的，利用矩阵乘法可以将 f(? + ?) 的问题转化为求 Mat(?) * Mat(?) 的问题，进而转化为寻常的树上 dp。 由于运算中矩阵都是某一个矩阵的幂，所以满足交换律。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (decay&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (decay&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const LL MOD = 1E9 + 7;const int maxm = 1E5 + 1;const int maxn = 2E5 + 10;struct Mat &#123; LL v[2][2]; inline void clear() &#123; v[0][0] = v[0][1] = v[1][0] = v[1][1] = 0; &#125;&#125;;void init();Mat operator * (Mat x, Mat y);Mat operator + (Mat x, Mat y);Mat operator - (Mat x, Mat y);Mat r[maxm], s[maxn], ans, cs[maxn];vector&lt;int&gt; G[maxn];int n, u, v, a[maxn];void dfs(int k, int fa) &#123; FOR(i, 0, G[k].size()) if (G[k][i] != fa) dfs(G[k][i], k); FOR(i, 0, G[k].size()) &#123; int t = G[k][i]; if (t == fa) continue; ans = ans + r[a[k]] * s[t] * (cs[k] - s[t]); s[k] = s[k] + s[t]; &#125; s[k] = s[k] * r[a[k]] + r[a[k]]; cs[fa] = cs[fa] + s[k]; ans = ans + s[k] + s[k] - r[a[k]];&#125;int main() &#123; init(); cin &gt;&gt; n; FOR(i, 1, n) &#123; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; FOR(i, 1, n + 1) scanf("%d", &amp;a[i]); dfs(1, 0); cout &lt;&lt; (ans.v[1][0] + ans.v[1][1]) % MOD &lt;&lt; endl;&#125;void init() &#123; Mat p; p.v[0][0] = 1; p.v[0][1] = 1; p.v[1][0] = 1; p.v[1][1] = 0; r[0].v[0][0] = r[0].v[1][1] = 1; FOR(i, 1, maxm) r[i] = r[i - 1] * p;&#125;Mat operator * (Mat x, Mat y) &#123; Mat ret; FOR(i, 0, 2) FOR(j, 0, 2) &#123; ret.v[i][j] = 0; FOR(k, 0, 2) ret.v[i][j] = (ret.v[i][j] + x.v[i][k] * y.v[k][j]) % MOD; &#125; return ret;&#125;Mat operator + (Mat x, Mat y) &#123; Mat ret; FOR(i, 0, 2) FOR(j, 0, 2) ret.v[i][j] = (x.v[i][j] + y.v[i][j]) % MOD; return ret;&#125;Mat operator - (Mat x, Mat y) &#123; Mat ret; FOR(i, 0, 2) FOR(j, 0, 2) ret.v[i][j] = (x.v[i][j] - y.v[i][j] + MOD) % MOD; return ret;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - Summing Pieces]]></title>
    <url>%2F2017%2F07%2F12%2FSumming-Pieces%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/summing-pieces 题意 给定一列数，分割成任意多段，某一种分法的值为每一段的数字和和段长之积之和，求所有方案的值的总和。 题解 首先写一个会超时的\(O(n^2)\)的算法 12345FOR(i, 1, n + 1) FOR(j, 0, i) &#123; cnt[i] += cnt[j]; // cnt[i] = 2 ^ (i - 1) dp[i] += dp[j] + (p[i] - p[j]) * (i - j) * cnt[j]; // p[i]: prefix sum &#125; 发现\(n\)个数有\(2^{n-1}\)种方案（可以理解为有\(n-1\)个空隙，每个空隙都可以选择是否插板） 根据数据范围，这道题目要求\(O(n)\)的算法 官方题解 https://www.hackerrank.com/challenges/summing-pieces/editorial 将 dp[i] 的和式进行变形，利用前缀和快速转移 题解 考虑长度为 l 的一段 它所有的位置覆盖每一个数的次数是这样的: 1, 2, … , m - 1, m, m, … , m, m - 1, …, 2, 1 (m = min(l, n + 1 - l)) 对于某一个位置 如果有一端在头或者尾，则被计算的次数为\(2^{n-l-1}\) 如果在中间，则被计算的次数为\(2^{n-l-2}\) 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (decay&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (decay&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const LL MOD = 1E9 + 7;const int maxn = 1E6 + 10;LL n, a[maxn], l[maxn], r[maxn], s[maxn], p[maxn] = &#123;1&#125;;LL dp[maxn], cnt[maxn] = &#123;1&#125;;inline LL go(LL x) &#123; return l[x] + r[n + 1 - x] + (s[n - x] - s[x]) * x;&#125;int main() &#123; FOR(i, 1, maxn) p[i] = (p[i - 1] * 2) % MOD; cin &gt;&gt; n; FOR(i, 1, n + 1) &#123; scanf("%lld", &amp;a[i]); l[i] = (i * a[i] + l[i - 1]) % MOD; s[i] = (a[i] + s[i - 1]) % MOD; &#125; FORD(i, n, 0) r[i] = (r[i + 1] + a[i] * (n + 1 - i)) % MOD; LL ans = n * s[n] % MOD; FOR(i, 1, n) &#123; int t = ((s[i] + s[n] - s[n - i]) % MOD + MOD) % MOD; if (i != n - 1) ans += (go(min(i, n + 1 - i)) - t) % MOD * i % MOD * p[n - i - 2]; ans += p[n - i - 1] * t % MOD * i % MOD; ans = (ans % MOD + MOD) % MOD; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - New Year Game]]></title>
    <url>%2F2017%2F07%2F10%2FNew-Year-Game%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/newyear-game 题意 给一列数，A 和 B 轮流取，如果每个人取的数之和之差的绝对值被 3 整除，则 B 赢，反之 A 赢。 题解 绝对值没有用，去掉 对于每个数，只关心它模 3 的余数 由于胜利条件不是无法操作，所以和 sg 无关 如果枚举每个状态，复杂度 \(O(n^3)\)，会超时。 但是如果找规律的话，能得出一个 \(O(n)\) 的做法，然后就 AC 了 对于模 3 余 0 的数，如果有偶数个就不影响胜负（显然），如果有奇数个就当成 1 个。所以复杂度变成了 \(O(n^2)\) 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (decay&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (decay&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;const int maxn = 2000 + 5;int a[3], T, n, t, k;bool dp[2][maxn][maxn][2][3];inline int f(int x) &#123; return (x + 3) % 3; &#125;void init() &#123; dp[0][0][0][0][1] = dp[0][0][0][0][2] = 1; // first person win dp[0][0][0][1][0] = 1; // second person win FOR(t, 0, 2) // 0 FOR(i, 0, maxn) // 1 FOR(j, 0, maxn) // 2 FOR(r, 0, 2) // 0: first, 1: second FOR(v, 0, 3) &#123; // S_first - S_second (mod 3) int s = r ? 1 : -1; bool &amp;u = dp[t][i][j][r][v]; if (t) u |= !dp[t - 1][i][j][r ^ 1][f(v - s * 0)]; if (i) u |= !dp[t][i - 1][j][r ^ 1][f(v - s * 1)]; if (j) u |= !dp[t][i][j - 1][r ^ 1][f(v - s * 2)]; &#125;&#125;int main() &#123; init(); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; memset(a, 0, sizeof a); FOR(i, 0, n) &#123; scanf("%d", &amp;t); ++a[t % 3]; &#125; if (dp[a[0] % 2][a[1]][a[2]][0][0]) puts("Balsa"); else puts("Koca"); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
        <tag>动态规划</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - Lena Sort]]></title>
    <url>%2F2017%2F07%2F08%2FLena-Sort%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/lena-sort 题意 题目中用伪代码给出一个排序算法，要求构造 1～n 的一个排列，使得排序过程中恰好比较了 k 次。 题解 玄学做法 先算出长度为 d 的序列至多至少比较多少次，至多是单调，至少是每次把剩余的数列分成尽可能均匀的两部分。 先按至多的方案填，如果填不下去了不行了就按照至少的方案填。保证在填的过程中有解。 官方题解 https://www.hackerrank.com/challenges/lena-sort/editorial 题目等价于构造一个 n 个节点二叉树，使得每个节点深度和为 k。 调整法。如果深度为 x 的那一层没有满，就可以把一个深度为 y 叶节点的深度变为 x，深度和减少了 y-x。 先把树造成一条链，然后从末端进行调整。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (remove_const&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (remove_const&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;const int maxn = 1E5 + 10;int f[maxn], T, n, d;int ans[maxn];inline bool check(int d, int k) &#123; return d == -1 || (f[d] &lt;= k &amp;&amp; k &lt;= 1LL * d * (d - 1) / 2);&#125;void fill(int x, int y, int k, int l, int r) &#123; if (x &gt; y) return; assert(check(y - x + 1, k)); int d = y - x; k -= d; while (d &gt;= 0 &amp;&amp; check(d, k)) &#123; // plan A ans[l++] = x++; k -= --d; &#125; if (d &gt; 0) &#123; // plan B int t = (x + y + 1) / 2; while (!check(y - t, k - f[t - x])) --t; assert(t &gt; x); ans[l] = t; fill(x, t - 1, f[t - x], l + 1, l + t - x); fill(t + 1, y, k - f[t - x], l + t - x + 1, r); &#125;&#125;int main() &#123; FOR(i, 2, maxn) f[i] = i - 1 + f[i / 2] + f[(i - 1) / 2]; cin &gt;&gt; T; while (T--) &#123; scanf("%d%d", &amp;d, &amp;n); if (!check(d, n)) puts("-1"); else &#123; fill(1, d, n, 1, d); FOR(i, 1, d + 1) printf("%d%c", ans[i], i == d ? '\n' : ' '); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - Yet Another Minimax Problem]]></title>
    <url>%2F2017%2F07%2F03%2FYet-Another-Minimax-Problem%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/yet-another-minimax-problem 题意 给出 n 个整数，求一个排列使得相邻两数的异或值的最大值最小，输出该值。 题解 如果有一位所有数都是 0 或 1，则异或之后这一位始终是 0。 如果有一位既有 1 又有 0，我可以把 1 和 0 各自放在一起，但是会由一个交界处，交界处的异或值的该位为 1，其他位置是 0。 问题就是找到所有数不完全相同的最高的那位，然后按那位是 0 或 1 分成两组，求两组分别取一个数是异或值最小。 利用 Trie 求一个数与一堆数异或的最小值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (remove_const&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (remove_const&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const int maxn = 3000 + 10;int n, a[maxn], b[maxn], la, lb, m;int trie[maxn * 20][2];int sz = 1;void add(int n) &#123; int u = 0; FORD(i, m - 1, -1) &#123; bool b = (1 &lt;&lt; i) &amp; n; if (!trie[u][b]) trie[u][b] = sz++; u = trie[u][b]; &#125;&#125;int query(int n) &#123; int u = 0, ret = 0; FORD(i, m - 1, -1) &#123; bool b = (1 &lt;&lt; i) &amp; n; if (!trie[u][b]) &#123; ret += (1 &lt;&lt; i); b ^= 1; &#125; u = trie[u][b]; &#125; return ret;&#125;int main() &#123; cin &gt;&gt; n; m = 0; LL p = -1, q = 0; FOR(i, 0, n) &#123; cin &gt;&gt; a[i]; p &amp;= a[i]; q |= a[i]; &#125; if (!(p ^ q)) &#123; puts("0"); return 0; &#125; m = 31 - __builtin_clz(p ^ q); FOR(i, 0, n) &#123; if (a[i] &amp; (1 &lt;&lt; m)) a[la++] = a[i]; else b[lb++] = a[i]; &#125; FOR(i, 0, la) add(a[i]); LL ans = 1E10; FOR(i, 0, lb) ans = min(ans, (LL)query(b[i])); cout &lt;&lt; ans + (1 &lt;&lt; m) &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - Sherlock's Array Merging Algorithm]]></title>
    <url>%2F2017%2F07%2F03%2FSherlock-s-Array-Merging-Algorithm%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/sherlocks-array-merging-algorithm/problem 题解 每一列的数在原数列中是连续且单调增的 每一列数的个数是单调减的 如果原数列是单调递增的，可以使用如下代码。其中 dp[i][j] 表示前 i 个数分成若干组且最后一组的大小为 j 的总方案数。 12345FOR(i, 1, n + 1) &#123; dp[i][i] = 1; FOR(j, 1, i + 1) &#123; FOR(k, j, i + 1) &#123; dp[i][j] += dp[i - j][k] * A(k, j); // A 是排列数 需要预处理阶乘和阶乘的逆元 看起来复杂度是\(O(n^3)\)的，但是其实是\(O(n^3/6)\)，所以竟然没有超时？ 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (remove_const&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (remove_const&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const int maxn = 1200 + 5;const int MOD = 1E9 + 7;LL dp[maxn][maxn], n, a[maxn], l[maxn];LL invf[maxn], factor[maxn];LL quick_inverse(LL n, LL p) &#123; LL ret = 1; LL exponent = p - 2; for (LL i = exponent; i; i &gt;&gt;= 1, n = n * n % p) &#123; if (i &amp; 1) &#123; ret = ret * n % p; &#125; &#125; return ret;&#125;void get_factorial_inverse(LL n, LL p) &#123; factor[0] = 1; for (LL i = 1; i &lt;= n; ++i) &#123; factor[i] = i * factor[i - 1] % p; &#125; invf[n] = quick_inverse(factor[n], p); for (LL i = n-1; i &gt;= 0; --i) &#123; invf[i] = invf[i + 1] * (i + 1) % p; &#125;&#125;inline LL A(LL n, LL m) &#123; return factor[n] * invf[n - m] % MOD; &#125;int main() &#123; cin &gt;&gt; n; get_factorial_inverse(n, MOD); FOR(i, 0, n) scanf("%lld", &amp;a[i]); l[0] = 1; FOR(i, 1, n) if (a[i] &gt;= a[i - 1]) l[i] = l[i - 1] + 1; else l[i] = 1; FOR(i, 1, n + 1) &#123; FOR(j, 1, l[i - 1] + 1) &#123; if (i == l[i - 1]) dp[i][i] = 1; FOR(k, j, i - j + 1) dp[i][j] = (dp[i][j] + dp[i - j][k] * A(k, j)) % MOD; &#125; &#125; LL ans = 0; FOR(i, 1, l[n - 1] + 1) ans += dp[n][i]; cout &lt;&lt; ans % MOD &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - Fair Cut]]></title>
    <url>%2F2017%2F07%2F02%2FFair-Cut%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/fair-cut 题意 给 n 个数，分成 k 和 n - k 两组，使得两个组之间任意数对之差的绝对值之和最小。 题解 将问题转化为对于两组数每组内部元素两两之差的绝对值之和的和最大 排个序把绝对值去了 对于一组有 k 个元素有序的数，两两之差之和的值为 Sum[a[i] * (2i + k - 1), {i, 1, k}] dp[i][j] 表示第一组取 i 个数，第二组取 j 个数 （可以开成滚动数组） 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (remove_const&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (remove_const&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const int maxn = 3000 + 5;LL dp[maxn][maxn], n, k, a[maxn];int main() &#123; cin &gt;&gt; n &gt;&gt; k; FOR(i, 0, n) cin &gt;&gt; a[i]; sort(a, a + n); FOR(i, 0, k + 1) FOR(j, 0, n - k + 1) &#123; dp[i][j] = (i || j) ? -1E18 : 0; if (i) dp[i][j] = max(dp[i - 1][j] + a[i + j - 1] * (2 * i - k - 1), dp[i][j]); if (j) dp[i][j] = max(dp[i][j - 1] + a[i + j - 1] * (2 * j - (n - k) - 1), dp[i][j]); &#125; LL ans = -dp[k][n - k]; FOR(i, 0, n) ans += a[i] * (2 * i - n + 1); cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - Decibinary Numbers]]></title>
    <url>%2F2017%2F07%2F02%2FDecibinary-Numbers%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/prime-xor 题意 定义一种新的数值表示方法，每一位权值和二进制一样，但是每一位都可以是 0～9。问第 k 大的数是几（如果表示的数值一样大的话，再看做十进制比较）。 题解 dp[i][j] 表示 i 用不超过 j 位表示的方案数 先估计一下范围，但是开一维 dp 做会有这样的问题：表示同样的值的数没法按数值大小排序。 12345678910FOR(i, 2, 1000000) &#123; FOR(j, 0, 10) if ((i - j) % 2 == 0) dp[i] += dp[(i - j) / 2]; // cerr &lt;&lt; i &lt;&lt; ' ' &lt;&lt; dp[i] &lt;&lt; endl; s += dp[i]; if (s &gt; 1E16) &#123; cerr &lt;&lt; dp[i] &lt;&lt; ' ' &lt;&lt; i &lt;&lt; endl; // 114928788468 285112 break; &#125;&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (remove_const&lt;decltype(y)&gt;::type i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (remove_const&lt;decltype(x)&gt;::type i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const int maxn = 285112 + 5, maxm = 20;LL dp[maxn][maxm], s[maxn] = &#123;1&#125;;LL T, n;void go(LL n, LL rank, LL pos, bool leading) &#123; // cerr &lt;&lt; n &lt;&lt; ' ' &lt;&lt; rank &lt;&lt; ' ' &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; leading &lt;&lt; endl; if (!pos) return; assert(n &gt;= 0 &amp;&amp; rank &gt;= 0); LL t = 1 &lt;&lt; (pos - 1); LL s = 0; FOR(i, 0, 10) &#123; if (s + dp[n - i * t][pos - 1] &lt;= rank) s += dp[n - i * t][pos - 1]; else &#123; if (!leading || i) cout &lt;&lt; i; go(n - i * t, rank - s, pos - 1, leading &amp;&amp; !i); return; &#125; &#125;&#125;int main() &#123; FOR(i, 0, maxm) dp[0][i] = 1; FOR(i, 1, maxn) &#123; s[i] = s[i - 1] + dp[i - 1][maxm - 1]; FOR(j, 1, maxm) &#123; dp[i][j] = dp[i][j - 1]; LL t = 1 &lt;&lt; (j - 1); FOR(k, 1, 10) if (t * k &lt;= i) dp[i][j] += dp[i - t * k][j - 1]; else break; &#125; &#125; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; LL k = upper_bound(s, s + maxn, n) - s - 1; go(k, n - s[k], maxm, 1); puts(""); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HackerRank - Prime XOR]]></title>
    <url>%2F2017%2F07%2F02%2FPrime-XOR%2F</url>
    <content type="text"><![CDATA[题目 https://www.hackerrank.com/challenges/prime-xor 题意 给 n 个介于 3500 和 4500 之间的数，求不同子集（可以包含重复元素）的总数，使得子集异或和是质数。 题解 异或和的范围在 0～8191 之间，虽然 n 很大，但是每一个数的范围很小，因此可以依次处理 3500～4500 之间的每一个数。 dp[i][k] = dp[i - 1][k] * (a[i] / 2 + 1) + dp[i - 1][k ^ v[i]] * ((a[i] + 1) / 2) dp[i][k]表示前 i 个数异或和为 k 的方案数 a[i]记录 n 个数中 i 出现的次数，(a[i] / 2 + 1) 表示取偶数个，((a[i] + 1) / 2) 表示取奇数个 v[i]表示第 i 个数的值 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define FOR(i, x, y) for (__typeof(y) i = (x), _##i = (y); i &lt; _##i; ++i)#define FORD(i, x, y) for (__typeof(x) i = (x), _##i = (y); i &gt; _##i; --i)using namespace std;typedef long long LL;const int MOD = 1E9 + 7;const int maxn = 8192 + 10;bool p[maxn];int t, a[5000], T, n, u;LL dp[2][maxn];int main() &#123; for (int i = 2; i &lt; maxn; ++i) if (!p[i]) for (int j = i + i; j &lt; maxn; j += i) p[j] = 1; scanf("%d", &amp;T); while (T--) &#123; memset(dp, 0, sizeof dp); u = 0; dp[0][0] = 1; memset(a, 0, sizeof a); scanf("%d", &amp;n); FOR(i, 0, n) &#123; scanf("%d", &amp;t); ++a[t]; &#125; FOR(i, 3500, 4501) if (a[i]) &#123; u ^= 1; FOR(j, 0, 8192) dp[u][j] = ((1 + a[i] / 2) * dp[u ^ 1][j] + (a[i] + 1) / 2 * dp[u ^ 1][j ^ i]) % MOD; &#125; LL ans = 0; FOR(i, 2, 8192) if (!p[i]) ans += dp[u][i]; printf("%lld\n", ans % MOD); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HackerRank</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 奇技淫巧]]></title>
    <url>%2F2017%2F06%2F17%2Fcpp-tricks%2F</url>
    <content type="text"><![CDATA[想了想，还是详见模板库吧。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法 - 博弈问题]]></title>
    <url>%2F2017%2F06%2F09%2FAlgorithms-Game-Theory%2F</url>
    <content type="text"><![CDATA[基本思想 游戏可以等效为一个有向图，每一个状态相当于图中的一个节点，而可能的状态转移是图中的边。如果必胜态的后继中存在必败态，而必败态的后继全是必胜态。 SG函数 \[ SG(u) = mex\{ SG(v)|u \to v \} \] 函数值为 0 代表必败态，不为 0 代表必胜态。（也就是说，0 只能转移到非 0，而非 0 一定能转移到 0。） 一个组合游戏的 SG 和等于所有子游戏的异或和。 ## Anti-SG 和 SJ 定理 Anti-SG 游戏： 走完最后一步的一方输，也就是说，SG 为 0 的局面不一定为终止局面。 SJ 定理： 对于 Anti-SG 游戏，如果游戏结束的条件是所有子游戏的 SG 值均为 0 时，那么先手必胜的条件是： SG 值不为零 xor 没有子游戏 SG 值大于1 Every-SG 每一个非终止状态的子游戏必须进行操作。 \[ step(v) = \begin{cases} 0, &amp; \text{$v$ 为终止状态} \\ max\{step(u)|SG(u)=0\}+1, &amp; \text{$SG(v)&gt;0$} \\ min\{step(u)\}, &amp; \text{$SG(v)=0$} \\ \end{cases} \] 先手必胜的充要条件：所有子游戏中最大的 step 值为奇数 Green Hackenbush 图上的删边游戏，过于复杂，自行搜索。 题目 解题思路 尽量将问题转换成 Nim 游戏计算 SG 和。 确定边界状态的 SG 值（不存在时为 -1） SG 计算过于复杂时打表找规律 zero-move 在 Nim 游戏的基础上增加一个规则，每一堆石子可以进行一次空操作（与玩家无关）。这道题看似同一次状态可以多次抵达，实则不然。同样多的石子，根据经历过空操作与否可以看做两个状态。 新的 SG 值： n 1 2 3 4 5 6 … SG 2 1 4 3 6 5 …]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Arch Linux - 大型攻略]]></title>
    <url>%2F2017%2F06%2F08%2FLinux-Another-Home%2F</url>
    <content type="text"><![CDATA[这篇文章的主要目的是记录我在使用 Linux 的过程中遇到的坑和相应的解决方案，次要目的是帮助读者快速构建一个舒适的 Linux 使用环境。后文的描述基于 Arch Linux 和 KDE 的方案，大部分也适用于 Kubuntu 用户。 UPDATE 2017.10 重装了系统，现在选择了基于 arch 的发行版 majaro（桌面环境还是 KDE），安装确实方便挺多，也称得上是开箱即用。 这两个月 shadowsocks-qt5 的最新版本很不好用，估计是依赖的问题（github 上 issue 不断）。所以还是选择了 shadowsocks-libev 命令行版本，配合 polipo socks5 转 HTTP 代理（其实不怎么用得到）。 发行版的选择 起初我选择的是 Ubuntu，其主要原因有如下几点： 用户的基数大，遇到问题能够方便得找到相应的解决方案 “网易云音乐”、“搜狗输入法”等应用提供的安装包是 Deb 包（ Ubuntu 可以直接安装，而 Debian 家族以外的发行版无法直接使用） 在使用 Ubuntu 将近一年后，我选择了 Arch Linux，它不仅拥有对我而言 Ubuntu 所有的优势，还提供了额外的便利： 官方仓库和用户软件仓库（AUR）提供了我想要的全部，包括上文中的“网易云音乐”和“搜狗输入法”。 拥有官方 Wiki，对于解决实际问题和学习 Linux 很有帮助 没有预装可有可无的软件包，用户拥有更大的选择余地 ## 安装 由于 Arch 的安装是在 CLI（命令行）下进行的，对于新用户可能有些困难。而在官方 Wiki 和网上教程的帮助下，完成安装应该也不成问题。 桌面环境的选择 在尝试过许多桌面环境后，我体会到了 KDE 的可贵。 可定制性远强于其他桌面环境。 有许多桌面控件可供选用（后文会有介绍）算法—— 博弈 可以很方便得修改 panel 的样式，于是我可以很轻松地将桌面从 Win10 风格切换至 OS X 风格。 可以在系统设置中修改动画效果 提供了虚拟桌面（Virtual desktops）和活动（Activities）的功能 可以修改主题、图标、窗口样式，而且默认主题十分美观 系统设置丰富 （有些东西没法通过图形界面设置的话就只能通过命令行或者修改配置文件来达到目的，十分不便） 有些集成的软件十分好用，比如文件管理器 dolphin，终端 konsole，便签 Knotes，快捷搜索 Lancelot（当然无论是什么桌面环境这些应用都可以做相应的替换，但是原生不容易出问题，体验也更为一致）。 缺点 集成了一些无用的软件，虽然可以在安装时进行筛选 设置中播放设备的选择太过繁琐 难以名状的 Bug，这个似乎很难避免，只要数量不多频率不高问题不大还是可以忍受一些的 KDE 的安装也十分便捷，参照 Wiki 即可，配合 SDDM 风味更佳。 常用软件 以下均为包名，可以直接安装（有些属于 AUR） base-devel chromium / firefox / google-chrome 浏览器三选一 shadowsocks-qt5 科学上网 wps-office &amp; ttf-wps-fonts WPS netease-cloud-music 网易云音乐 （字变成方块，间歇性白屏，沙盒无法启动，各种问题的解决方法在 AUR 讨论区里有。链接） youdao-dict 有道词典 fcitx-sogoupinyin 搜狗拼音 calibre 电子书管理 atom 文本编辑器 redshift 屏幕色温调节 uget 多线程下载工具，支持磁链、种子（如果选用 aria2 作为后端，还需安装 aria2） vlc 视频播放器 p7zip-natspec &amp; unzip-natspec 使压缩包管理软件 Ark 解压（不是查看）zip、7z时避免出现中文文件名编码错误的问题 ntfs-3g 挂载 ntfs 分区（访问 Windows 分区或 ntfs 的移动硬盘） 以下软件给出安装方法 Mathematica 数学计算 Jetbrains IDE (可以通过 AUR 安装) QQ的安装 解决方案：crossover 16 或 deepin-QQ with crossover 15 参考链接 crossover 16 有对多个版本的 QQ 的官方支持，建议购买正版，有试用期。 备选方案：crossover 15 的 crack 对 16 同样有效，需要的人自己找。 另：如果发现许多字变为方块，那么安装 crossover 中的 QQ 2012，期间安装的一些依赖可以解决这个问题。 Atom相关 项目的开发我还是建议使用 IDE，要让编辑器能拥有 IDE 的功能可能需要花大量的精力来改造。 apm Atom 的包管理器 apm 其实就是 npm，于是我们可以通过类似的方法为其设置镜像来加快下载速度。 12npm set registry https://registry.npm.taobao.orgapm config set registry https://registry.npm.taobao.org 插件 linter linter-gcc file-icons platformio-ide-terminal 这个好像也不怎么好用，推荐一发下拉式终端 yakuake 桌面控件 Redshift Control 控制 redshift Netspeed Widget 网速监控 Event Calendar 带天气和倒计时的日历，可以和谷歌日历同步日程 Thermal Monitor 温度监测 PlayBar2 播放控制 Latte Dock 美观好用的 dock 额外 Wallpaper Switcher 不同虚拟桌面可以设置不同壁纸的特性作为 bug 在某一个版本后消失了，但许多用户认为这是一个好功能。于是一个 KDE 的开发人员兑现承诺开发了这个工具提供了这个功能。 Active Window Control窗口在最大化后还会保留系统标题栏，而屏幕顶部还有一个 panel（如果和我一样把状态栏放到顶部），这样就会有两层，既不美观又浪费了空间。通过安装这个控件并且设置全屏隐藏标题栏后，可以达到和 OS X 同样的全屏后合并标题栏和系统状态栏的效果。 易用性 按键映射 创建文件～/.Xmodmap，fcitx 会自动读取并应用 xmodmap 的设置 以下是我使用的配置文件，将Caps_Lock修改为Ctrl，并交换`~ 和Esc 12345remove Lock = Caps_Lockkeysym Caps_Lock = Control_Ladd Control = Control_Lkeysym Escape = grave asciitilde grave asciitildekeysym grave = Escape 鼠标侧键 对于拥有鼠标侧键的用户而言，将这些侧键映射为常用快捷键（如浏览器标签页的切换、虚拟桌面的切换）可以带来极大的便捷。 我使用的软件是 xbindkeys，在~/.xbindkeysrc中修改配置，以下是我使用的配置 12345678910111213# 侧键切换虚拟桌面&quot;xte &apos;keydown Super_L&apos; &apos;key Tab&apos; &apos;keyup Super_L&apos;&quot; b:8&quot;xte &apos;keydown Super_L&apos; &apos;key Tab&apos; &apos;keyup Super_L&apos;&quot; b:9# 水平滚轮切换浏览器标签页，延迟是为了防止切换过快&quot;xte &apos;keydown Control_L&apos; &apos;usleep 200000&apos; &apos;key Tab&apos; &apos;keyup Control_L&apos;&quot; b:7&quot;xte &apos;keydown Control_L&apos; &apos;keydown Shift_L&apos; &apos;usleep 200000&apos; &apos;key Tab&apos; &apos;keyup Shift_L&apos; &apos;keyup Control_L&apos;&quot; b:6 与 Google Drive 文件同步 使用grive，由于对应 GUI 工具grive-tools不支持代理，因此无法使用。 替代方案：在系统设置中添加计划任务进行定时同步。 参考文章 https://blog.hanschen.org/2009/10/13/mouse-shortcuts-with-xbindkeys/ https://wiki.archlinux.org/index.php/Mouse_buttons#xvkbd_and_xbindkeys ### 触控板手势 对于长期使用触控板的用户来说，多指手势可以用来替代许多快捷键。 我使用的软件是 Touchegg以及对应的 GUI 配置工具 touchegg-gce-git Tips dolphin 中Alt + .切换是否显示隐藏文件 更新 kernel 之后不要忘记重启 yaourt -Syu频率太低会更新失败，太高会占用大量硬盘空间（/var/cache/pacman/pkg/） arch 是为数不多的关闭 user namespace 的发行版之一，所以 unprivileged container 无法使用 如果 PGP 签名挂了 那么 1234sudo rm -rf /etc/pacman.d/gnupgsudo pacman-key --initsudo pacman-key --populate archlinuxsudo pacman-key --refresh-keys 与其手动下载安装包，不如去 AUR 找一找，这样更新会省力不少。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[你好，世界！]]></content>
  </entry>
</search>