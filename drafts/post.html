<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zerol.me","root":"/","scheme":"Gemini","version":"8.0.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="写在最前自制一个 C++ 的 Parser Combinator，并用它写一个 json 的 parser，目标是代码尽可能简洁且便于理解（换句话说，就是一个玩具）。文章分为几个阶段，每一阶段后都有相应的代码，方便渐进式学习。 前置知识：基本的模板元编程，基本的 STL 用法，对 C++17 和 C++20 的特性有一些了解。但是如果你愿意查阅 cppreference，那么不需要任何前置知识了。">
<meta property="og:type" content="website">
<meta property="og:title" content="C++ 自制 Parser Combinator">
<meta property="og:url" content="https://zerol.me/drafts/post.html">
<meta property="og:site_name" content="Zerol&#39;s Notes">
<meta property="og:description" content="写在最前自制一个 C++ 的 Parser Combinator，并用它写一个 json 的 parser，目标是代码尽可能简洁且便于理解（换句话说，就是一个玩具）。文章分为几个阶段，每一阶段后都有相应的代码，方便渐进式学习。 前置知识：基本的模板元编程，基本的 STL 用法，对 C++17 和 C++20 的特性有一些了解。但是如果你愿意查阅 cppreference，那么不需要任何前置知识了。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-10-26T10:48:25.000Z">
<meta property="article:modified_time" content="2020-10-27T06:18:30.000Z">
<meta property="article:author" content="zerol">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zerol.me/drafts/post">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>C++ 自制 Parser Combinator | Zerol's Notes
</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-100757043-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-100757043-1');
      }
    </script>






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zerol's Notes</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D"><span class="nav-number">1.</span> <span class="nav-text">写在最前</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BB%84%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">简单的字符组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC-Parser"><span class="nav-number">2.1.</span> <span class="nav-text">接收字符串的基本 Parser</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%AD%90-seq"><span class="nav-number">2.2.</span> <span class="nav-text">组合子 - seq</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95-optional-%E5%B9%B6%E6%94%B9%E5%86%99"><span class="nav-number">2.3.</span> <span class="nav-text">扩展 optional 并改写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%AD%90-alt"><span class="nav-number">2.4.</span> <span class="nav-text">组合子 - alt</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97"><span class="nav-number">3.</span> <span class="nav-text">四则运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Json-%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">Json 解析器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5"><span class="nav-number">5.</span> <span class="nav-text">更进一步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-number">6.</span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95-optional"><span class="nav-number">6.1.</span> <span class="nav-text">扩展 optional</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-variant-%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.2.</span> <span class="nav-text">std::variant 的连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="nav-number">7.</span> <span class="nav-text">写在最后</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA-C-%E7%9A%84-Parser-Combinator%EF%BC%9F"><span class="nav-number">7.1.</span> <span class="nav-text">我为什么需要一个 C++ 的 Parser Combinator？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%80%A0%E8%BD%AE%E5%AD%90%EF%BC%9F"><span class="nav-number">7.2.</span> <span class="nav-text">我为什么要造轮子？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CHECKPOINTS"><span class="nav-number">9.</span> <span class="nav-text">CHECKPOINTS</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zerol"
      src="/images/alpha.png">
  <p class="site-author-name" itemprop="name">zerol</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">139</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zerolfx/template" title="ACM 模板库 → https:&#x2F;&#x2F;github.com&#x2F;zerolfx&#x2F;template" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i>ACM 模板库</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://acm.ecnu.edu.cn/wiki/index.php?title=ECNU_Foreigners_(2018)" title="训练记录 → https:&#x2F;&#x2F;acm.ecnu.edu.cn&#x2F;wiki&#x2F;index.php?title&#x3D;ECNU_Foreigners_(2018)" rel="noopener" target="_blank"><i class="fa fa-tasks fa-fw"></i>训练记录</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:z@zerol.me" title="E-Mail → mailto:z@zerol.me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.jxtxzzw.com/" title="https:&#x2F;&#x2F;www.jxtxzzw.com" rel="noopener" target="_blank">jxtxzzw</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.secrul.cn/" title="http:&#x2F;&#x2F;www.secrul.cn&#x2F;" rel="noopener" target="_blank">secrul</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.rooobin.top/" title="https:&#x2F;&#x2F;www.rooobin.top&#x2F;" rel="noopener" target="_blank">rooobin</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://cubercsl.cn/" title="http:&#x2F;&#x2F;cubercsl.cn&#x2F;" rel="noopener" target="_blank">cubercsl</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://xiejiadong.com/" title="http:&#x2F;&#x2F;xiejiadong.com&#x2F;" rel="noopener" target="_blank">xiejiadong</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/calabash_boy" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;calabash_boy" rel="noopener" target="_blank">calabash_boy</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://dengtesla.com/" title="http:&#x2F;&#x2F;dengtesla.com" rel="noopener" target="_blank">D-Tesla</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://fuckgfw.org/" title="http:&#x2F;&#x2F;fuckgfw.org" rel="noopener" target="_blank">Minty_He</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://godweiyang.com/" title="http:&#x2F;&#x2F;godweiyang.com&#x2F;" rel="noopener" target="_blank">godweiyang</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner page posts-expand">
      
  
  

      

    
    
    
    <div class="post-block" lang="en">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">C++ 自制 Parser Combinator
</h1>

<div class="post-meta-container">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>自制一个 C++ 的 Parser Combinator，并用它写一个 json 的 parser，目标是代码尽可能简洁且便于理解（换句话说，就是一个玩具）。文章分为几个阶段，每一阶段后都有相应的代码，方便渐进式学习。</p>
<p>前置知识：基本的模板元编程，基本的 STL 用法，对 C++17 和 C++20 的特性有一些了解。但是如果你愿意查阅 cppreference，那么不需要任何前置知识了。</p>
<a id="more"></a>

<h2 id="简单的字符组合"><a href="#简单的字符组合" class="headerlink" title="简单的字符组合"></a>简单的字符组合</h2><h3 id="接收字符串的基本-Parser"><a href="#接收字符串的基本-Parser" class="headerlink" title="接收字符串的基本 Parser"></a>接收字符串的基本 Parser</h3><p>首先定义 <code>Parser</code> 类型和 <code>ParseResult</code> 的类型。</p>
<p>Parser 的结果可能成功可能失败，如果成功的话会得到一个值，所以就借用 <code>std::optional</code>，如果空就代表失败。</p>
<p>Parser 干的事情就是接受一个字符串并消耗掉它的若干字符，然后给出一个输出。它本质上是一个函数，输入是一个可能被修改的字符串，这里就用 <code>std::string_view&amp;</code> 了，所以它的类型就是 <code>std::function&lt;ParseResult&lt;T&gt;(std::string_view&amp;)&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> ParseResult = <span class="built_in">std</span>::optional&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Parser = <span class="built_in">std</span>::function&lt;ParseResult&lt;T&gt;(<span class="built_in">std</span>::string_view&amp;)&gt;;</span><br></pre></td></tr></table></figure>

<p>最简单的就是接收一个字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Parser&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">literal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="built_in">std</span>::string_view&amp; in)-&gt;ParseResult&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (in.starts_with(s)) &#123;</span><br><span class="line">      in.remove_prefix(s.length());</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不用测试就能看出如此简陋的功能应该没什么问题。</p>
<h3 id="组合子-seq"><a href="#组合子-seq" class="headerlink" title="组合子 - seq"></a>组合子 - seq</h3><p>光有这个还没什么用，接下来就来添加一个最简单的 Combinator，也就是连接函数 <code>seq</code>。目标是 <code>literal(&quot;a&quot;) &amp; literal(&quot;b&quot;)</code> 能接受 <code>&quot;ab&quot;</code> 同时返回一个 <code>(&quot;a&quot;, &quot;b&quot;)</code> 的 <code>tuple</code>。之所以是 <code>tuple</code>，因为参与连接的 Parser 类型不一定相同，对于 <code>Parser&lt;T1&gt;, Parser&lt;T2&gt;, ...</code> 连接的结果是 <code>Parser&lt;std::tuple&lt;T1, T2, ...&gt;&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Parser&lt;<span class="built_in">std</span>::tuple&lt;&gt;&gt; <span class="title">seq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [](<span class="built_in">std</span>::string_view&amp;)-&gt;ParseResult&lt;<span class="built_in">std</span>::tuple&lt;&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> R = <span class="built_in">std</span>::tuple&lt;T, Ts...&gt;&gt;</span><br><span class="line">Parser&lt;R&gt; seq(<span class="keyword">const</span> Parser&lt;T&gt;&amp; p, <span class="keyword">const</span> Parser&lt;Ts&gt;&amp; ...ps) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="built_in">std</span>::string_view&amp; in)-&gt;ParseResult&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">auto</span> v = p(in);</span><br><span class="line">    <span class="keyword">if</span> (!v) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> vs = seq(ps...)(in);</span><br><span class="line">    <span class="keyword">if</span> (!vs) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::tuple_cat(<span class="built_in">std</span>::make_tuple(v.value()), vs.value());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = literal(<span class="string">&quot;a&quot;</span>), b = literal(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> ab = seq(a, b);</span><br><span class="line"><span class="built_in">std</span>::string_view in&#123;<span class="string">&quot;ab&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = ab(in).value();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// output: a b</span></span><br></pre></td></tr></table></figure>

<p>注：为什么不弄成二元组合子，重载 <code>&amp;</code>，就能搞出更加自然的 <code>Parser&lt;T1&gt; &amp; Parser&lt;T2&gt; &amp; ...</code> 呢？因为有点麻烦。考虑一下类型，最左边的 &amp; 的签名类似于 <code>(Parser&lt;T1&gt;, Parser&lt;T2&gt;) ⇒ Parser&lt;(T1, T2)&gt;</code>，其他的 <code>&amp;</code> 的签名类似于 <code>(Parser&lt;(Ts...)&gt;, Parser&lt;T&gt;) ⇒ Parser&lt;(Ts..., T)&gt;</code>，有一些需要特殊处理的东西。</p>
<p>CHECKPOINT 1</p>
<h3 id="扩展-optional-并改写"><a href="#扩展-optional-并改写" class="headerlink" title="扩展 optional 并改写"></a>扩展 optional 并改写</h3><p>众所周知，<code>optional</code> 是一个 <code>monad</code>，但是 STL 里提供的方法有点少，所以我对其做了一些扩展（见附录），然后后一个 <code>seq</code> 函数可以写成这样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// change ParseResult from std::optional to optional (see appendix for definition)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> ParseResult = optional&lt;T&gt;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> R = <span class="built_in">std</span>::tuple&lt;T, Ts...&gt;&gt;</span><br><span class="line">Parser&lt;R&gt; seq(<span class="keyword">const</span> Parser&lt;T&gt;&amp; p, <span class="keyword">const</span> Parser&lt;Ts&gt;&amp; ...ps) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="built_in">std</span>::string_view&amp; in)-&gt;ParseResult&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> p(in).flat_map([&amp;](<span class="keyword">auto</span> v) &#123;</span><br><span class="line">      <span class="keyword">return</span> seq(ps...)(in).<span class="built_in">map</span>([&amp;](<span class="keyword">auto</span> vs) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::tuple_cat(<span class="built_in">std</span>::make_tuple(v), vs); </span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 C++ lambda 语法限制，所以似乎更难看了，如果有很甜的语法糖就好了（做梦中）。</p>
<p>CHECKPOINT 2</p>
<h3 id="组合子-alt"><a href="#组合子-alt" class="headerlink" title="组合子 - alt"></a>组合子 - alt</h3><p><code>alt</code> 是蛋疼的开始，由于 <code>alt</code> 的结果是若干类型之一，所以用 <code>std::variant&lt;T1, T2, ...&gt;</code> 作为结果。但是把一个 <code>std::variant</code> 和一个类型不一定在内的元素组合起来并没有那么容易。具体见附录中 <code>std::variant</code> 的讨论。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Parser&lt;T&gt; <span class="title">attempt</span><span class="params">(<span class="keyword">const</span> Parser&lt;T&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="built_in">std</span>::string_view&amp; in)-&gt;ParseResult&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">auto</span> in_bak = in;</span><br><span class="line">    <span class="keyword">auto</span> v = p(in);</span><br><span class="line">    <span class="keyword">if</span> (!v) in = in_bak;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line">  <span class="function">Parser&lt;R&gt; <span class="title">alt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [](<span class="built_in">std</span>::string_view&amp;)-&gt;ParseResult&lt;R&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">  <span class="function">Parser&lt;R&gt; <span class="title">alt</span><span class="params">(<span class="keyword">const</span> Parser&lt;T&gt;&amp; p, <span class="keyword">const</span> Parser&lt;Ts&gt;&amp; ...ps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [=](<span class="built_in">std</span>::string_view&amp; in)-&gt;ParseResult&lt;R&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> attempt(p)(in).<span class="built_in">map</span>([](<span class="keyword">auto</span> v)&#123; <span class="keyword">return</span> R&#123;v&#125;; &#125;)</span><br><span class="line">          .or_else(alt&lt;R&gt;(ps...)(in));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">alt</span><span class="params">(<span class="keyword">const</span> Parser&lt;Ts&gt;&amp; ...ps)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> detail::alt&lt;<span class="keyword">unique_variant_t</span>&lt;Ts...&gt;&gt;(ps...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> a = literal(<span class="string">&quot;a&quot;</span>), b = literal(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> ab_ba = alt(seq(a, b), seq(a, a));</span><br><span class="line">  <span class="built_in">std</span>::string_view in&#123;<span class="string">&quot;aab&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> [x, y] = <span class="built_in">std</span>::get&lt;<span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;(ab_ba(in).value());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// a a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>attempt</code> 的存在，因为对于 <code>alt</code>，单个 Parser 失败时需要回溯。如果没有的话，对于代码中的例子，第一个可选项 <code>ab</code> 会把 <code>aab</code> 中的第一个 <code>a</code> 吃掉，然后再匹配 <code>aa</code> 时就会失败。</p>
<p>测试代码中的 <code>get</code> 非常恶心，所以最好处理一下，如果 <code>variant</code> 中只有一种类型，那么直接返回这个类型，而不是 <code>variant</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">flat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::variant&lt;Ts...&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(Ts) == <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T, <span class="keyword">typename</span> R = <span class="built_in">std</span>::<span class="keyword">invoke_result_t</span>&lt;F, T&gt;&gt;</span><br><span class="line">Parser&lt;R&gt; <span class="keyword">operator</span> % (<span class="keyword">const</span> Parser&lt;T&gt;&amp; p, F&amp;&amp; f) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="built_in">std</span>::string_view&amp; in)-&gt;ParseResult&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> p(in).<span class="built_in">map</span>([&amp;](T v) &#123; <span class="keyword">return</span> f(v); &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESOLVE_OVERLOAD(...) \\</span></span><br><span class="line">	[](<span class="keyword">auto</span>&amp;&amp;...args)-&gt;<span class="keyword">decltype</span>(<span class="keyword">auto</span>)&#123;<span class="keyword">return</span> __VA_ARGS__(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">alt</span><span class="params">(<span class="keyword">const</span> Parser&lt;Ts&gt;&amp; ...ps)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> detail::alt&lt;<span class="keyword">unique_variant_t</span>&lt;Ts...&gt;&gt;(ps...) % RESOLVE_OVERLOAD(detail::flat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> a = literal(<span class="string">&quot;a&quot;</span>), b = literal(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> ab_ba = alt(seq(a, b), seq(a, a));</span><br><span class="line">  <span class="built_in">std</span>::string_view in&#123;<span class="string">&quot;aab&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> [x, y] = ab_ba(in).value();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入了一个很重要的东西，就是运算符 <code>%</code>（只是为了写起来方便），其实就是 map，但是这次是对于 Parser 的 <code>map</code> 而不是 <code>optional</code> 的 <code>map</code>。另外为什么要有这个恶心的 <code>RESOLVE_OVERLOAD</code>，在我的另一篇博客中有讲，这里就省略了。可以看到，对于相同类型的 <code>alt</code>，用户就不会拿到繁琐的 <code>std::variant</code> 作为结果了，<code>std::variant</code> 只会在必要的时候出现。</p>
<p>CHECKPOINT 3</p>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><p>首先是 number 的 parser，为此加了 <code>many</code> 和 <code>ch</code>，<code>many</code> 就是尽可能多的应用 parser，<code>ch</code> 就是接受一个符合特定条件的字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;</span><br><span class="line">Parser&lt;R&gt; many(<span class="keyword">const</span> Parser&lt;T&gt;&amp; p) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="built_in">std</span>::string_view&amp; in)-&gt;ParseResult&lt;R&gt; &#123;</span><br><span class="line">    R r;</span><br><span class="line">    ParseResult&lt;T&gt; v;</span><br><span class="line">    <span class="keyword">while</span> ((v = attempt(p)(in))) &#123;</span><br><span class="line">      r.emplace_back(v.value());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R = <span class="keyword">char</span>&gt;</span><br><span class="line">Parser&lt;R&gt; ch(<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">char</span>)&gt;&amp; f) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="built_in">std</span>::string_view&amp; in)-&gt;ParseResult&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (in.empty() || !f(in[<span class="number">0</span>])) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">char</span> c = in[<span class="number">0</span>];</span><br><span class="line">    in.remove_prefix(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> number = many(ch(<span class="built_in">isdigit</span>)) % [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v) &#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c: v) r = r * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::string_view in = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number(in).value() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就能搞表达式了（得先消除左递归）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Parser&lt;T&gt; <span class="title">lazy</span><span class="params">(<span class="keyword">const</span> Parser&lt;T&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [p_addr = &amp;p](<span class="built_in">std</span>::string_view&amp; in)-&gt;ParseResult&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (*p_addr)(in);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> R = <span class="built_in">std</span>::<span class="keyword">invoke_result_t</span>&lt;F, Ts...&gt;&gt;</span><br><span class="line">Parser&lt;R&gt; <span class="keyword">operator</span> % (<span class="keyword">const</span> Parser&lt;<span class="built_in">std</span>::tuple&lt;Ts...&gt;&gt;&amp; p, F&amp;&amp; f) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="built_in">std</span>::string_view&amp; in)-&gt;ParseResult&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> p(in).<span class="built_in">map</span>([&amp;](<span class="keyword">auto</span> v) &#123; <span class="keyword">return</span> <span class="built_in">std</span>::apply(f, v); &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> eval = [](<span class="keyword">int</span> x, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; v) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [op, y]: v) &#123;</span><br><span class="line">      <span class="keyword">if</span> (op == <span class="string">&quot;*&quot;</span>) x *= y;</span><br><span class="line">      <span class="keyword">if</span> (op == <span class="string">&quot;/&quot;</span>) x /= y;</span><br><span class="line">      <span class="keyword">if</span> (op == <span class="string">&quot;+&quot;</span>) x += y;</span><br><span class="line">      <span class="keyword">if</span> (op == <span class="string">&quot;-&quot;</span>) x -= y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Parser&lt;<span class="keyword">int</span>&gt; <span class="built_in">exp</span>;</span><br><span class="line">  Parser&lt;<span class="keyword">int</span>&gt; number = many(ch(<span class="built_in">isdigit</span>)) % [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v) &#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c: v) r = r * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Parser&lt;<span class="keyword">int</span>&gt; factor = alt(</span><br><span class="line">      seq(literal(<span class="string">&quot;(&quot;</span>), lazy(<span class="built_in">exp</span>), literal(<span class="string">&quot;)&quot;</span>)) % [](<span class="keyword">auto</span> x)&#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(x); &#125;,</span><br><span class="line">      number</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  Parser&lt;<span class="keyword">int</span>&gt; term = seq(</span><br><span class="line">    factor,</span><br><span class="line">    many(seq(</span><br><span class="line">      alt(literal(<span class="string">&quot;*&quot;</span>), literal(<span class="string">&quot;/&quot;</span>)),</span><br><span class="line">      factor))) % eval;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">exp</span> = seq(</span><br><span class="line">      term,</span><br><span class="line">      many(seq(</span><br><span class="line">          alt(literal(<span class="string">&quot;+&quot;</span>), literal(<span class="string">&quot;-&quot;</span>)),</span><br><span class="line">          term))) % eval;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::string_view in = <span class="string">&quot;4+(1+2)*3+100+100&quot;</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">exp</span>(in).value() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Remain: &quot;</span> &lt;&lt; in &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又引入了一个新的函数 <code>lazy</code>，因为 expression 是递归定义的，而且为了方便，所有 parser 都是按值捕获的，然后运行到 <code>factor</code> 时发现 <code>exp</code> 没定义就炸了。因此就提前声明 <code>exp</code>，并用 <code>lazy</code> 使它捕获一个 <code>exp</code> 的地址用于运行时计算。</p>
<p>顺便重载了运算符 <code>%</code>，方便应用于 <code>Parser&lt;std::tuple&lt;...&gt;&gt;</code> 也就是 <code>seq</code> 的返回值，这样就不用一个一个 <code>std::get</code> 了。</p>
<p>那这样计算器就完成了，但还有一个让人有些不爽的问题，表达式里不允许有空格。</p>
<p>CHECKPOINT 4</p>
<h2 id="Json-解析器"><a href="#Json-解析器" class="headerlink" title="Json 解析器"></a>Json 解析器</h2><p>为了证明这些东西是能用的，所以就写一个 Json Parser 吧。最后搞出来的 Json 可能在 parse 浮点数时漏了一点情况（主要是网上找了几个 json 浮点数 EBNF，感觉都不大对），但是目的是展示自制的 parser combinator 库是可以用的，所以正确性也无伤大雅。另外为了简化，整数和浮点数是存成了字符串。</p>
<p>首先把拆分了一下文件，全写在一个文件里显得有些杂乱了。</p>
<p>Json 这个东西在语法上是递归的，而 <code>std:variant</code> 本身是不能递归自己的（因为它不是在堆上分配内存的），但是可以套一层 smart pointer（因为支持用 incomplete type 定义），所以弄出来这样一个类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Json</span>;</span></span><br><span class="line"><span class="keyword">using</span> JsonPtr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Json&gt;;</span><br><span class="line"><span class="keyword">using</span> JsonV = <span class="built_in">std</span>::variant&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;JsonPtr&gt;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, JsonPtr&gt;&gt;&gt;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Json</span> &#123;</span></span><br><span class="line">  Json(JsonV v): v(v) &#123;&#125;</span><br><span class="line">  JsonV v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外增加了一个叫 printer 的头文件，用于输出 <code>tuple</code>, <code>variant</code>, <code>optional</code>, <code>vector</code> 等类型，方便调试使用。在 helper 中，增加了 <code>sep_by</code>（相当于用分隔符 parser 分隔的 <code>many</code>），<code>raw</code>（不管原先 parser 的类型，输出吃掉的那部分输入字符串），<code>eof</code>（当 parser 运行结束后恰好输入也结束才算成功）。</p>
<p>最后的 json parser 长这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;zpc/helper.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;zpc/printer.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Json</span>;</span></span><br><span class="line"><span class="keyword">using</span> JsonPtr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Json&gt;;</span><br><span class="line"><span class="keyword">using</span> JsonV = <span class="built_in">std</span>::variant&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;JsonPtr&gt;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, JsonPtr&gt;&gt;&gt;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Json</span> &#123;</span></span><br><span class="line">  Json(JsonV v): v(v) &#123;&#125;</span><br><span class="line">  JsonV v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> Json&amp; json) &#123;</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; json.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ws = many(ch([](<span class="keyword">char</span> c) &#123; <span class="keyword">return</span> <span class="built_in">isspace</span>(c); &#125;));</span><br><span class="line">  <span class="keyword">auto</span> tok = [&amp;](<span class="keyword">auto</span>&amp;&amp; p) &#123; <span class="keyword">return</span> seq(p, ws) % RESOLVE_OVERLOAD(<span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;); &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> sign = alt(lit(<span class="string">&quot;+&quot;</span>), lit(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">  <span class="keyword">auto</span> digit = ch_range(<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> json_int = alt(</span><br><span class="line">      lit(<span class="string">&quot;0&quot;</span>),</span><br><span class="line">      seq(ch_range(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>), many(digit))</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">auto</span> json_exp = seq(</span><br><span class="line">      alt(lit(<span class="string">&quot;E&quot;</span>), lit(<span class="string">&quot;e&quot;</span>)),</span><br><span class="line">      opt(sign),</span><br><span class="line">      json_int</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">auto</span> float_part = seq(lit(<span class="string">&quot;.&quot;</span>), many1(digit));</span><br><span class="line">  Parser&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; json_number = tok(raw(seq(</span><br><span class="line">      opt(sign),</span><br><span class="line">      alt(</span><br><span class="line">          seq(json_int, opt(float_part)),</span><br><span class="line">          float_part</span><br><span class="line">      ),</span><br><span class="line">      opt(json_exp)</span><br><span class="line">  )));</span><br><span class="line"></span><br><span class="line">  Parser&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; json_string = tok(alt(</span><br><span class="line">  seq(lit(&quot;\\&quot;&quot;), raw(many(ch([](char c) &#123; return c != &#x27;&quot;&#x27;; &#125;))), lit(&quot;\\&quot;&quot;)),</span><br><span class="line">  seq(lit(<span class="string">&quot;&#x27;&quot;</span>), raw(many(ch([](<span class="keyword">char</span> c) &#123; <span class="keyword">return</span> c != <span class="string">&#x27;&quot;&#x27;</span>; &#125;))), lit(<span class="string">&quot;&#x27;&quot;</span>))</span><br><span class="line">  )) % RESOLVE_OVERLOAD(<span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;);</span><br><span class="line"></span><br><span class="line">  Parser&lt;JsonPtr&gt; json_val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> lazy_json_val = lazy(json_val);</span><br><span class="line"></span><br><span class="line">  Parser&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;JsonPtr&gt;&gt; json_arr = tok(seq(</span><br><span class="line">      tok(lit(<span class="string">&quot;[&quot;</span>)),</span><br><span class="line">      sep_by(lazy_json_val, tok(lit(<span class="string">&quot;,&quot;</span>))),</span><br><span class="line">      tok(lit(<span class="string">&quot;]&quot;</span>))</span><br><span class="line">  )) % RESOLVE_OVERLOAD(<span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;);</span><br><span class="line"></span><br><span class="line">  Parser&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, JsonPtr&gt;&gt;&gt; json_obj =</span><br><span class="line">      tok(seq(</span><br><span class="line">          tok(lit(<span class="string">&quot;&#123;&quot;</span>)),</span><br><span class="line">          sep_by(</span><br><span class="line">              seq(</span><br><span class="line">                  json_string, tok(lit(<span class="string">&quot;:&quot;</span>)), lazy_json_val</span><br><span class="line">              ) %= [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;k, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;, <span class="keyword">const</span> JsonPtr &amp;v) &#123; <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(k, v); &#125;,</span><br><span class="line">              tok(lit(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">          ),</span><br><span class="line">          tok(lit(<span class="string">&quot;&#125;&quot;</span>))</span><br><span class="line">      )) % RESOLVE_OVERLOAD(<span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;);</span><br><span class="line"></span><br><span class="line">  Parser&lt;JsonV&gt; _json_val = tok(alt(</span><br><span class="line">      json_number,</span><br><span class="line">      json_string,</span><br><span class="line">      tok(lit(<span class="string">&quot;true&quot;</span>)),</span><br><span class="line">      tok(lit(<span class="string">&quot;false&quot;</span>)),</span><br><span class="line">      tok(lit(<span class="string">&quot;null&quot;</span>)),</span><br><span class="line">      json_arr,</span><br><span class="line">      json_obj</span><br><span class="line">  ));</span><br><span class="line">  json_val = _json_val % [](<span class="keyword">const</span> JsonV &amp;v) &#123; <span class="keyword">return</span> <span class="built_in">std</span>::make_shared&lt;Json&gt;(v); &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> json = eof(json_obj);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::string_view in = <span class="string">R&quot;|(&#123;</span></span><br><span class="line"><span class="string">    &quot;a&quot;: [1, 2, 3],</span></span><br><span class="line"><span class="string">    &quot;b&quot;: 1,</span></span><br><span class="line"><span class="string">    &quot;c&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;x&quot;: 1.1,</span></span><br><span class="line"><span class="string">      &quot;y&quot;:.1e2,</span></span><br><span class="line"><span class="string">      &quot;z&quot;: -2.e+2</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;)|&quot;</span>;</span><br><span class="line">  <span class="keyword">auto</span> res = json(in);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// ?:[(&quot;a&quot;, V&#123;[V&#123;&quot;1&quot;&#125;, V&#123;&quot;2&quot;&#125;, V&#123;&quot;3&quot;&#125;]&#125;), (&quot;b&quot;, V&#123;&quot;1&quot;&#125;), (&quot;c&quot;, V&#123;[(&quot;x&quot;, V&#123;&quot;1.1&quot;&#125;), (&quot;y&quot;, V&#123;&quot;.1e2&quot;&#125;), (&quot;z&quot;, V&#123;&quot;-2.e+2&quot;&#125;)]&#125;)]</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Remain: &quot;</span> &lt;&lt; in &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CHECKPOINT 5</p>
<h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><ul>
<li>优雅解决空格</li>
<li>使用 packrat，解决左递归问题</li>
<li>错误信息</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="扩展-optional"><a href="#扩展-optional" class="headerlink" title="扩展 optional"></a>扩展 optional</h3><p>函数名参考了 Scala 的 <code>Option[T]</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">optional</span> :</span> <span class="built_in">std</span>::optional&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  optional() : <span class="built_in">std</span>::optional&lt;T&gt;() &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Q&gt;</span><br><span class="line">  optional(Q&amp;&amp; v) : <span class="built_in">std</span>::optional&lt;T&gt;(<span class="built_in">std</span>::forward&lt;Q&gt;(v)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::optional&lt;T&gt;::has_value;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::optional&lt;T&gt;::value;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::optional&lt;T&gt;::value_or;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::optional&lt;T&gt;::<span class="keyword">operator</span> <span class="keyword">bool</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> Q = <span class="built_in">std</span>::<span class="keyword">invoke_result_t</span>&lt;F, T&gt;&gt;</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">map</span>(F&amp;&amp; f) &#123; <span class="comment">// f: T =&gt; ?</span></span><br><span class="line">    <span class="keyword">if</span> (!has_value()) <span class="keyword">return</span> optional&lt;Q&gt;();</span><br><span class="line">    <span class="keyword">return</span> optional&lt;Q&gt;(f(value()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> Q = <span class="built_in">std</span>::<span class="keyword">invoke_result_t</span>&lt;F, T&gt;&gt;</span><br><span class="line">  <span class="keyword">auto</span> flat_map(F&amp;&amp; f) &#123; <span class="comment">// f : T =&gt; optional&lt;?&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (!has_value()) <span class="keyword">return</span> Q();</span><br><span class="line">    <span class="keyword">return</span> f(value());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">or_else</span><span class="params">(<span class="keyword">const</span> optional&lt;T&gt;&amp; alternative)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!has_value()) <span class="keyword">return</span> alternative;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="std-variant-的连接"><a href="#std-variant-的连接" class="headerlink" title="std::variant 的连接"></a>std::variant 的连接</h3><p><code>std::variant</code> 中包含的元素类型是可以重复的，但是对于重复的元素类型进行操作会有一些限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::variant&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">double</span>&gt; v;</span><br><span class="line">v = <span class="number">1.0</span>;</span><br><span class="line">v = <span class="number">1</span>; <span class="comment">// compile error</span></span><br><span class="line">v.emplace&lt;<span class="number">0</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> x = <span class="built_in">std</span>::get&lt;<span class="keyword">double</span>&gt;(v);</span><br><span class="line"><span class="keyword">auto</span> x = <span class="built_in">std</span>::get&lt;<span class="keyword">int</span>&gt;(v); <span class="comment">// compile error</span></span><br><span class="line"><span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(v);</span><br></pre></td></tr></table></figure>

<p>看上去似乎也只是麻烦了一些。但是考虑这样一个情景，我要写一个对于 <code>variant</code> 的函数 <code>map</code>，接受一个函数和 <code>variant</code>，返回一个新的 <code>variant</code>。如果类型都不相同，那么可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> V = <span class="built_in">std</span>::variant&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; x)-&gt;<span class="built_in">std</span>::variant&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> v_int = <span class="built_in">std</span>::visit(f, V&#123;<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> v_double = <span class="built_in">std</span>::visit(f, V&#123;<span class="number">1.0</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>但是有相同类型的话，根据输入的 index 来决定输出的 index 也行，但是 STL 把 index 设计成模板参数，想要 runtime 有点麻烦。</p>
<p>因此对于合并一个 <code>std::variant</code> 和一个可能已经存在也可能不存在的 type，有两种方法，一种就是保证 unique，如果已经存在就类型不变，另一种就是始终把这个类型加进去。我实现了一下后者（之所以不是 append 而是 prepend 因为 alt 是 foldr 的）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> I, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_by_index</span><span class="params">(<span class="built_in">std</span>::variant&lt;Ts...&gt;&amp; variant, <span class="keyword">size_t</span> idx, T&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    assert(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx + <span class="number">1</span> == I) &#123;</span><br><span class="line">    variant.<span class="keyword">template</span> emplace&lt;I - <span class="number">1</span>&gt;(x);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    emplace_by_index&lt;I - <span class="number">1</span>&gt;(variant, idx, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> R = <span class="built_in">std</span>::variant&lt;T, Ts...&gt;&gt;</span><br><span class="line">R prepend_variant_type(<span class="keyword">const</span> <span class="built_in">std</span>::variant&lt;Ts...&gt;&amp; variant) &#123;</span><br><span class="line">  R r;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; variant.index() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  emplace_by_index&lt;<span class="built_in">std</span>::variant_size_v&lt;R&gt;&gt;(r, variant.index() + <span class="number">1</span>, <span class="built_in">std</span>::visit([](<span class="keyword">auto</span>&amp;&amp; x)&#123; <span class="keyword">return</span> x; &#125;, variant));</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::variant&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; v;</span><br><span class="line">  v.emplace&lt;<span class="number">0</span>&gt;(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">auto</span> vv = prepend_variant_type&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(v);</span><br><span class="line">  <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same_v&lt;<span class="keyword">decltype</span>(vv), <span class="built_in">std</span>::variant&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;&gt;);</span><br><span class="line">  assert(vv.index() == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是考虑到用户代码，写 visitor 的时候并不能拿到 index 来区分，不写 visitor 而是判断 index 就很蠢，所以这种方法不仅麻烦，也不能方便用户，所以就放弃了。</p>
<p>此时需要一个 unique_variant，之后就再也不碰 <code>std::variant</code> 的 index 了，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... List&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> is_in_list = (<span class="built_in">std</span>::is_same_v&lt;T, List&gt; || ...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">variant_concat</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">variant_concat</span>&lt;T, std::variant&lt;Ts...&gt;&gt; &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">std</span>::variant&lt;T, Ts...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unique_variant</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">std</span>::<span class="keyword">conditional_t</span>&lt;</span><br><span class="line">      is_in_list&lt;T, Ts...&gt;,</span><br><span class="line">      <span class="keyword">typename</span> unique_variant&lt;Ts...&gt;::type,</span><br><span class="line">      <span class="keyword">typename</span> variant_concat&lt;T, <span class="keyword">typename</span> unique_variant&lt;Ts...&gt;::type&gt;::type</span><br><span class="line">  &gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unique_variant</span>&lt;T&gt; &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">std</span>::variant&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">unique_variant_t</span> = <span class="keyword">typename</span> unique_variant&lt;Ts...&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same_v&lt;<span class="keyword">unique_variant_t</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;, <span class="built_in">std</span>::variant&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same_v&lt;<span class="keyword">unique_variant_t</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="keyword">double</span>&gt;, <span class="built_in">std</span>::variant&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><h3 id="我为什么需要一个-C-的-Parser-Combinator？"><a href="#我为什么需要一个-C-的-Parser-Combinator？" class="headerlink" title="我为什么需要一个 C++ 的 Parser Combinator？"></a>我为什么需要一个 C++ 的 Parser Combinator？</h3><p>每年的九月份，对于大四的计科学生，就到了编译原理实践的季节。相比起去年（也就是我亲身经历那个季节），愚蠢的老师因为自己的无知限定了编程语言（C, C++, Java, C#）。（题外话：这绝对是扼杀创新力的，虽然只会影响到一小部分人，我和  K 分别把它当成了熟悉 Scala 和 Rust 的机会。）再让我选择的话，肯定得用一个 Parser Combinator（由此否决了 Antlr，lex &amp; yacc 一众代码生成的库），由于我讨厌 Java，以及考虑到 C# 的学习成本（其实只是觉得学了没啥用），就只有 C++ 这一个选项了。</p>
<h3 id="我为什么要造轮子？"><a href="#我为什么要造轮子？" class="headerlink" title="我为什么要造轮子？"></a>我为什么要造轮子？</h3><p>其实 <a target="_blank" rel="noopener" href="https://github.com/LPeter1997/CppCmb">CppCmb</a> 相当符合我的需求，但是我就是要造轮子。</p>
<p><a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/1_72_0/libs/spirit/doc/x3/html/index.html">Boost Spirit X3</a> 功能挺全的，但是有很多 boilerplate code，写起来浑身难受。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/taocpp/PEGTL">PEGTL</a> 算是 star 最多 C++ parser combinator 项目了，很牛逼，利用元编程的编译器 parser combinator，写代码时 CLion 非常非常卡，占用非常非常多内存，就算开省电模式也没用。一度决定使用这个库，但是调试起来实在是太折磨了，还有就是文档和它 release 的代码不匹配，API 还要靠猜，这个实在是没办法。</p>
<p>然后还有不少 star 数比较少的项目，可能之后也会成为它们的一员。我觉得我的 Parser Combinator Library 的好处就是代码少，适合这篇博客的产出，以及给别人一些启发（如果真的有人看的话）。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/beark/ftl/blob/master/docs/Parsec-I.md">https://github.com/beark/ftl/blob/master/docs/Parsec-I.md</a> 非常函数式的 C++ Parser Combinator</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/28997271/c11-way-to-index-tuple-at-runtime-without-using-switch">https://stackoverflow.com/questions/28997271/c11-way-to-index-tuple-at-runtime-without-using-switch</a> 如何对于 tuple 使用 runtime 的 index，对于 variant 也是同理</li>
<li><a target="_blank" rel="noopener" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese</a> 不错的函数式入门教程，帮我复习了一下（中文版少了一章）</li>
<li><a target="_blank" rel="noopener" href="https://www.slideshare.net/alexandrgranin/monadic-parsers-in-c">https://www.slideshare.net/alexandrgranin/monadic-parsers-in-c</a> 一个 PPT，有很多函数签名可供参考（但并没有实现）</li>
<li>《Haskell函数式编程入门（第2版）》 10.7 和 14.1 章，可以看到 Haskell 中赋予 Parser 以 Functor Monad Applicative Alternative 非常方便以及 parsec 库的使用</li>
<li><a target="_blank" rel="noopener" href="https://netcan.github.io/2020/09/16/C-%E5%85%83%E7%BC%96%E7%A8%8B%E4%B9%8BParser-Combinator/">https://netcan.github.io/2020/09/16/C-元编程之Parser-Combinator/</a> 利用 constexpr 编译期 parser</li>
</ul>
<h2 id="CHECKPOINTS"><a href="#CHECKPOINTS" class="headerlink" title="CHECKPOINTS"></a>CHECKPOINTS</h2>
      </div>
      
      
      
    </div>
    

    
    
    


      
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zerol</span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>















  








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://zerolblog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://zerol.me/drafts/post.html";
    this.page.identifier = "drafts/post.html";
    this.page.title = "C++ 自制 Parser Combinator";
    };
  NexT.utils.loadComments('#disqus_thread', () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://zerolblog.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
